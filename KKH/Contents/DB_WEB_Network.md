## DB

### RDBMS VS NoSQL에 대해서 설명해주세요.

---

**핵심답변**

RDBMS는 엑셀의 형식과 유사한 2차원 테이블 형식으로 구성되며 속성(Attribute)과 값(Value)을 이용하여 데이터를 정의하고 저장, 관리합니다. 각각의 속성과 값을 가진 테이블들은 외래 키(foreign key)를 사용하여 서로 관계를 맺습니다. 또한, SQL이라는 언어를 활용합니다.

NoSQL은 SQL 언어를 사용하지 않는 데이터베이스 관리 시스템으로 RDBMS 방식으로는 처리할 수 없는 복잡하고 큰 데이터들을 처리하는데 용이합니다. 정해진 스키마도 없고 테이블 간의 관계를 정의하지 않습니다.  따라서 Key값만 가지고 데이터에 대한 입출력을 수행하게 됩니다.

![image](https://user-images.githubusercontent.com/82690689/154992527-824eebdc-cfa0-4a0d-8436-73cf589d8625.png)

[https://im-designloper.tistory.com/67](https://im-designloper.tistory.com/67)

<br>

🤔 **RDB가 무엇인가요?**

RDB란 관계형 데이터 모델에 기초를 두고 모든 데이터를 2차원 테이블 형태로 표현하는 데이터베이스입니다. 구성된 테이블이 다른 테이블들과 관계를 맺고 모여있는 집합체라고 할 수 있습니다. 이런 관계를 나타내기 위해 외래 키(foreign key)를 사용하고 이를 이용한 테이블 간 Join이 가능하다는 것이 큰 특징입니다.

<br>

🤔 **DBMS가 무엇인가요?**

Database Management System으로 데이터베이스를 관리해 주는 소프트웨어입니다.

<br>

🤔 **RDBMS가 무엇인가요?**

관계형 데이터베이스를 생성하고 수정하고 관리할 수 있는 소프트웨어입니다.

<br>

🤔 **SQL이 무엇인가요?**

관계형 데이터베이스 관리 시스템(RDBMS)의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어이며, 관계형 데이터베이스 관리 시스템에서 자료의 검색과 관리, 스키마 생성과 수정, 객체 접근 조정 관리를 위해 개발되었습니다.

SQL의 예시로는 Mysql, Oracle Database 등이 있습니다.

<br>

🤔 **NoSQL**

SQL을 사용하지 않는 데이터베이스 관리 시스템을 지칭하는 단어입니다. 

NoSQL의 예시로는 mongoDB, redis 등이 있습니다.

---

[RDBMS와 NoSQL의 차이점 완벽 정리](https://universitytomorrow.com/26)

<br><br>

### 인덱스에 대해서 설명해주세요.

---

**핵심답변**

추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키 위한 자료 구조입니다. 즉, 데이터베이스의 목차부분이라고 할 수 있습니다.

<br>

🤔 **데이터베이스에 index를 만들면 내부적으로 어떤 동작이 이루어지는지 설명해주시고 장단점에 대해 설명해주세요.**

인덱스를 컬럼에 주게 되면 초기 테이블을 생성할 때, 컬럼을 색인화 하여 저장합니다. 이때, 저장된 형태는 B TREE의 형태를 갖추고 있습니다. 그래서 사용자가 인덱스가 적용된 컬럼을 조회하게 되면, 해당 테이블을 검색하는 것이 아니라 B TREE를 검색하여 빠른 검색을 할 수 있게 해줍니다.

만약 인덱스를 사용하지 않는 컬럼을 조회하게 되면 테이블을 풀 스캔하여 검색합니다.

이러한 특징 덕분에 아래와 같은 여러 장 단점을 갖고 있습니다.

- 테이블을 조회하고 정렬하는 속도를 향상시킵니다.
- 전반적인 시스템의 부하를 줄일 수 있습니다.
- 인덱스를 관리하기 위해 DB에 약 10퍼센트의 해당하는 저장공간이 필요합니다.
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하됩니다.

추가적으로 테이블에 조회 이외의 삽입,수정,삭제가 일어날 경우 인덱스 B TREE에도 해당 변경사항이 적용되기 때문에 아래와 같은 단점도 추가적으로 존재합니다.

- 삽입, 수정, 삭제작업의 경우 성능이 저하됩니다.

<br>

🤔 **데이터베이스에 index를 만들면 성능이 빨라지게 되는 이유를 설명해주세요.**

이유는 바로 인덱스가 갖는 저장 구조인 B TREE에 있습니다.

정렬이 되어 있는 B TREE는 조회하려는 값에 대한 위치가 저장되어 있는 노드를 루트 노드부터 리프 노드 순으로 흐르며, 해당 노드를 빠르게 찾을 수 있게 만들어 줍니다. 또한, B TREE의 리프노드는 링크드리스트로 연결되어 있기 때문에, 순차 검색 연산 성능을 용이하게 해주기 때문입니다.

인덱스의 시간 복잡도는 O(logN)이며, 일반적인 테이블을 풀 스캔하는 방식의 시간 복잡도는 O(N)을 갖습니다. 이런 이유로 데이터의 양이 일정 수준을 넘어설 때, 인덱스를 만드는 것이 성능이 향상시킵니다.

<br>

🤔 **hash index를 사용했을 때의 단점과 이유를 설명해주세요.**

해시 인덱스는 데이터의 (컬럼의 값, 데이터의 위치)를 (key, value)로 사용하여 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현합니다.

하지만, 해시 인덱스는 부등호 연산(<, >)이 자주 사용되는 데이터베이스 검색에 적합하지 않다는 단점이 있습니다, 예를 들어 “나는”으로 시작하는 모든 데이터를 검색하기 위한 쿼리문은 인덱스의 혜텍을 전혀 받지 못합니다.

이러한 이유는 해시 함수의 특징에 있는데, 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하기 때문입니다. 즉, 해시 인덱스는 키들의 값이 서로 유사해도 전혀 다른 해시 값을 갖기 때문에 부등호 연산을 할 경우 풀스캔을 하게 되어 인덱스의 기능의 효과가 전혀 없다고 볼 수 있습니다.

<br>

🤔**인덱스에 왜 해쉬보다 B Tree를 쓰는지 설명해주세요.**

데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있습니다. 이러한 이유로 순차 검색 연산이 불가능한 해쉬보다는 B Tree를 사용하고 있습니다. 또한, B Tree는 리프노드들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 B Tree를 인덱스에 맞게 최적화했기 때문에, 인덱스에 B Tree를 사용합니다.

<br>

🤔 **B Tree가 무엇이고 동작과정을 설명해주세요.**

[B+TREE 동작 과정](https://kyungyeon.dev/posts/66)

<br>

**🤔 이진 트리가 무엇인가요?**

각각의 노드가 최대 두 개의 자식 노드를 가지는 트리 자료 구조입니다. 

- 정이진트리 : 모든 레벨에서 노드가 꽉 채워진 이진트리입니다.
- 완전이진트리 : 마지막 레벨을 제외한 모든 레벨에서 노드들이 꽉 채워진 이진트리입니다.

- 참고

트리의 가장 큰 특징은 ‘루트 노드’를 제외한 모든 노드는 ‘단 하나의 부모노드만을 가진다.’는 것입니다. 이러한 특징을 벗어나면 트리가 아닙니다.

---

[인덱스란?](https://mangkyu.tistory.com/96)

[B+TREE와 B-TREE](https://zorba91.tistory.com/293)

<br><br>

### 트랜잭션에 대해서 설명해주세요.

---

**핵심답변**

트랜잭션(Transaction)이란 데이터베이스의 상태를 변화시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미합니다.

즉, 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위입니다.

<br>

**🤔 트랜잭션을 사용할 때의 장점은 무엇인가요?**

예상치 못한 상황에서 오류가 발생하면 롤백을 통해 데이터의 부정합을 방지해줍니다.

예) 은행 어플을 통해 돈을 송금하는 중에 오류가 발생해도 전혀 반영하지 않은 상태로 롤백해줍니다.

<br>

**🤔 트랜잭션의 특성에 대해 설명해주세요.(ACID)**

- Atomicity(원자성)
    
    트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 합니다.
    
- Consistency(일관성)
    
    트랜잭션이 진행되는 동안에 데이터베이스가 변경되더라도 업데이트된 데이터베이스로 트랜잭션이 진행되는 것이 아닌 트랜잭션이 진행하기 전 참조한 데이터베이스로 진행되어야 합니다.
    
- Isolation(독립성, 격리성)
    
    둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없고 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없습니다.
    
- Durablility(영속성, 지속성)
    
    성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 합니다.
    
<br>

🤔 **트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해주세요.**

- Read Uncommit : 트랜잭션의 변경 내용이 커밋이나 롤백에 상관없이 다른 트랜잭션에서 조회됩니다.(더티 리드)
- Read Commit : 트랜잭션의 변경 내용이 커밋되어야만 다른 트랜잭션에서 조회할 수 있습니다. 이는 트랜잭션의 특성 중 일관성에 어긋납니다.
- Repetable Read : 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있습니다. 트랜잭션 도중 변경된 데이터는 언두 영역에 백업된 데이터를 조회하게 됩니다.(MySQL 기본 세팅)
- Serializable : 가장 엄격한 격리 수준으로 읽기 작업에도 공유 잠금을 설정하여 동시에 다른 트랜잭션에서 해당 데이터를 변경하지 못하게 하는 것입니다. 이런 특성 때문에 동시처리 능력이 다른 격리 수준에 비해 떨어지고 성능저하가 발생합니다.

<br>

**🤔 트랜잭션이 Repetable Read 격리 수준을 갖고있을 때, 트랜잭션 도중 업데이트 된 데이터를 업데이트하려고하면 어떻게 되는지 설명해주세요.**

Repeatable Read 격리 수준은 트랜잭션이 시작된 시점의 데이터를 일관되게 보여주는 것을 보장해야 하기 때문에  언두 영역에 로그를 남겨놓게 됩니다. 이런 상황에서 하위 트랜잭션이 해당 데이터를 업데이트하기 위해 해당 데이터에 대해 쓰기 잠금을 시도하려하지만, 해당 레코드는 존재하지 않으므로 아무 변경도 일어나지 않게 됩니다. 즉, 상위 트랜잭션에서 발생한 업데이트만 적용되고 하위 트랜잭션에서 동작한 업데이트는 적용되지 않습니다.

궁금한 점?! 하위 트랜잭션이 커밋까지 완료가 될까 아니면 롤백이 될까? 커밋되면 데이터 정합성에 문제가 발생하는 거 아닌가?

<br>

**🤔 잠금 타임아웃과 교착 상태가 발생하는 이유에 대해서 설명해주세요.**

- 잠금 타임아웃
    
    갱신과 갱신이 부딪치는 경우, 나중에 온 갱신은 잠금 대기 상태가 됩니다.
    
    이때, 설정한 값보다 길게 대기할 경우 잠금 타임아웃이 발생합니다.
    

- 교착 상태
    
    트랜잭션 A와 트랜잭션 B가 서로 다른 테이블의 잠금을 얻었을 때, 잠금을 유지한 채 서로 잠금을 건 자원에 잠금이 필요한 처리를 실행해서 아무리 기다려도 상황이 바뀌지 않을 때 교착 상태가 발생합니다.
    

<br>

**🤔 트랜잭션 Rollback은 어떤 경우에 하나요?**

트랜잭션의 실행 중 장애가 발생한 경우에 수행됩니다.

이때, 원인이 트랜잭션 자체의 논리적인 오류가 아닌 경우에는 트랜잭션이 재시작되며, 반대로 트랜잭션 내부의 논리적인 오류에 의해 오류를 수정해야 하는 상황이거나 얻고자 하는 데이터가 데이터베이스에 존재하지 않는 경우에 강제 종료합니다.

---

[https://mangkyu.tistory.com/30](https://mangkyu.tistory.com/30)

<br><br>

### JPA - ORM이란 무엇인가요?

---

**핵심답변**

ORM이란 객체와 관계형 데이터를 매핑하기 위한 기술입니다. 그리고 JPA는 자바 ORM 기술에 대한 API 표준 명세입니다. 즉, 인터페이스의 모음입니다. 이러한 JPA 인터페이스를 구현한 대표적인 프레임워크가 하이버네이트입니다. JPA는 애플리케이션과 JDBC 사이에서 동작합니다.

![image](https://user-images.githubusercontent.com/82690689/154992616-02a7ff7f-bd9c-4d22-9e89-6c60c6b2c512.png)

[https://doing7.tistory.com/m/105](https://doing7.tistory.com/m/105)

<br>

🤔 **JPA, Hibernate 그리고 Spring Data JPA 각각에 대해서 설명해주세요.**

JPA는 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스입니다. 즉 기술 명세라고 할 수 있습니다.

Hibernate는 JPA의 구현체입니다. 즉, JPA를 사용하기 위한 프레임워크라고 보면 됩니다.

Spring Data JPA는 JPA를 쓰기 편하게 만들어놓은 모듈입니다. JPA를 한 단계 추상화시킨 Repository라는 인터페이스를 제공함으로써 개발자가 Repository의 구현에서 JPA를 사용하고있다고 볼 수 있다.

![image](https://user-images.githubusercontent.com/82690689/154992646-bd896078-a6a6-45f6-8599-6af6cda28cc5.png)

[https://suhwan.dev/2019/02/24/jpa-vs-hibernate-vs-spring-data-jpa/](https://suhwan.dev/2019/02/24/jpa-vs-hibernate-vs-spring-data-jpa/)

<br>

🤔 **데이터 정합성에 대해서 설명해주세요. JPA에서 이것들을 어떻게 처리하나요?**

데이터 정합성이란, 서로 모순이 없이 일관되게 일치해야 한다는 의미입니다.

JPA에는 영속성 컨텍스트가 있는데, 이곳에서 1차 캐쉬에서 엔티티와 스냅샷을 비교하여 정합성을 유지합니다. 이러한 1차 캐쉬의 단위는 트랜잭션의 단위와 동일합니다.

<br>

🤔 **DB Lock에 대해서 설명해주세요. JPA에서 이것들을 어떻게 처리하나요?**

- 트랜잭션 처리의 순차성을 보장하기 위한 방법
- 락의 종류
    - Shared Lock : 데이터를 읽을 때 사용되는 락으로 공유 락은 공유 락끼리 동시에 접근이 가능합니다.
    - Exclusive Lock : 베타 락은 데이터를 변경하고자 하는 경우에 사용되며, 베타락은 락이 해제될 때 까지 다른 트랜잭션에서 해당 리소스로 접근할 수 없습니다.
- 락의 설정 범위(level)
    - 데이터베이스 : 데이터 베이스 전체를 기준으로 락을 걸 수 있습니다.
    - 파일 : 데이터베이스 파일을 기준으로 락을 설정할 수 있습니다.
    - 테이블 : 테이블을 기준으로 락을 설정합니다.
    - 페이지와 블럭 : 파일의 일부인 페이지와 블록을 기준으로 락을 설정합니다.
    - 컬럼 : 컬럼을 기준으로 락을 설정합니다.
    - 행 : 1개의 행을 기준으로 락을 설정합니다. 가장 일반적으로 사용하는 락입니다.
- JPA에서도 동시에 데이터 업데이트를 발생시킬 경우에 일부 요청이 유실되는 경우에 대한 관리를 위해 여러 종류의 락을 제공합니다.
    - 낙관적 잠금(Optimistic Lock)
        
        데이터 갱신시 충돌이 발생하지 않을 것이라고 낙관적으로 보고 잠금을 거는 기법으로 @Version 어노테이션을 필드에 넣어주는 것으로 사용할 수 있습니다. Version이라는 속성을 확인하여 엔티티의 변경사항을 감지하는 메커니즘입니다.
        
    - 비관적 잠금(Pessimistic Lock)
        
        트랜잭션의 충돌이 발생한다고 가정하고 우선 락을 걸고 보는 방법으로 트랜잭션 안에서 서비스 로직이 진행되어야 합니다. 비관적 잠금 메커니즘은 데이터베이스 수준에서 엔티티 잠금을 포함합니다.
        

[https://velog.io/@lsb156/JPA-Optimistic-Lock-Pessimistic-Lock#jpa의-낙관적-잠금optimistic-lock-비관적-잠금pessimistic-lock](https://velog.io/@lsb156/JPA-Optimistic-Lock-Pessimistic-Lock#jpa%EC%9D%98-%EB%82%99%EA%B4%80%EC%A0%81-%EC%9E%A0%EA%B8%88optimistic-lock-%EB%B9%84%EA%B4%80%EC%A0%81-%EC%9E%A0%EA%B8%88pessimistic-lock)

---

<br><br>

### QueryDSL을 사용하는 이유와 JPQL과 차이점에 대해서 설명해주세요.

---

**핵심답변**

Spring Data JPA가 기본적으로 제공하는 CRUD 메서드 및 쿼리 메서드 기능으로 부족한 기능을 보강하기 위해서 사용하고 또한, JPQL을 사용하기 위해 직접 쿼리문을 작성할 때 발생하는 오타 혹은 문법적인 오류로부터 에러를 방지하고자 QueryDSL을 사용합니다.

- 차이점

JPQL의 경우 직접 쿼리 스트링을 입력해줘야하는 반면 QueryDSL은 자바 코드로 이뤄져있어 문법과 오타에 대한 에러를 개발단계에서 잡을 수 있습니다.

- QueryDSL 장점
    - 문자가 아닌 코드로 쿼리를 작성함으로써, 컴파일 시점에 문법 오류를 쉽게 확인할 수 있습니다.
    - 자동완성 등 IDE의 도움을 받을 수 있습니다.
    - 동적인 쿼리 작성이 편리합니다.
    - 쿼리 작성시 제약 조건등을 메서드 추출을 통해 재사용할 수 있습니다.

---

<br><br>

### 정규화에 대해서 설명해주세요.

---

**핵심답변**

정규화란 데이터베이스를 설계할 때 고려해봐야할 사항으로 기본적인 목표로는 테이블 간에 중복된 데이터를 허용하지 않는다는 것에 있습니다.  이를 통해 무결성을 유지하고 DB의 낭비되는 용량을 줄일 수 있게 됩니다.

- 제 1 정규화 : 테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분해하는 것입니다.
- 제 2 정규화 : 제 1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것입니다.
- 제 3 정규화 : 제 2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것입니다.
- BCNF 정규화 : 제 3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것입니다.

1. 완전 함수 종속 : 기본키의 부분집합이 결정자가 되어선 안된다.
2. 이행적 종속 : A가 B를 B가 C를 성립할 때, A가 C라는 논리가 성립되는 것을 의미합니다.

[https://mangkyu.tistory.com/110](https://mangkyu.tistory.com/110)

<br>

**🤔 Nomalization이 무엇인가요? Denormalization은 무엇이고, 언제 시행하게 되는지 설명해주세요.**

비정규화는 정규화를 마친 후에 조회 성능을 향상시키기 위해 데이터를 중복하거나 그룹핑하는 과정을 의미합니다.

[http://wiki.gurubee.net/pages/viewpage.action?pageId=28606676](http://wiki.gurubee.net/pages/viewpage.action?pageId=28606676)

---

<br><br>

### Elastic Search에 대해서 간단하게 설명해주세요.

---

**핵심답변**

Apache Lucene(아파치 루씬) 기반의 JAVA 오픈소스 분산 검색 엔진입니다.

이를 통해 루씬 라이브러리르 단독으로 사용할 수 있게 되었으며, 방대한 양의 데이터를 신속하게, 거의 실시간으로 저장, 검색, 분석할 수 있습니다.

ELK 스택으로 사용되기도 합니다.

- Logstash : 로그 또는 트랜잭션 데이터를 수집, 집계, 파싱하여 엘라스틱 서치로 전달
- Elasticsearch : 로그스태시로부터 받은 데이터를 검색 및 집계를 하여 필요한 관심 있는 정보를 흭득
- Kibana : 데이터를 시각화 및 모니터링

🤔 Elastic Search의 인덱스구조와 RDBMS의 인덱스 구조의 차이에 대해 설명해주세요.

🤔 Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.

---

<br><br>

### SQL 문법

---

🤔 A라는 테이블이 존재할 때, 새로운 속성(Column)을 추가한다고 할때, 모든 행(row)에 Default값을 넣어주고 싶을때, 어떤 쿼리문을 작성해야할까요?

ALTER TABLE A ADD COLUMN newColumn INT;

ALTER TABLE A ALTER COLUMN newColumn SET DEFAULT 10;

[https://byul91oh.tistory.com/319](https://byul91oh.tistory.com/319)
