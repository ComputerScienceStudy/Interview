# DB
## Relational 데이터베이스와 NoSQL 데이터베이스의 차이에 대해서 설명해주세요.
### 핵심답변
Relational DB는 데이터베이스를 이루는 객체들의 관계 통해서 데이터를 저장하는 데이터베이스입니다.             
SQL을 사용해 데이터의 저장, 질의, 수정, 삭제를 할 수 있으며               
데이터를 효율적으로 보관하는 것을 목적으로 하고 구조화가 굉장히 중요합니다.          
장점으로는 명확한 데이터 구조를 보장하고, 중복을 피할 수 있습니다.          

NoSQL DB는 Realational DB에 비해 자유로운 형태로 데이터를 저장합니다.           
또한 수평확장을 할 수 있고 분산처리를 지원합니다.            
다양한 형태의 NoSQL 데이터베이스가 있고, 대표적으로 key-value store, document db, graph db 등이 있습니다.         

둘은 대체될 수 있는 것이 아니고, 각각 필요한 시점에 적절히 선택해서 사용해야 합니다. 둘 다 같이쓰는 상호보완적인 존재가 될 수도 있습니다.
<br><br>
#### 🤔 관계형 데이터베이스는 관계를 어떻게 맺을 수 있나요?
관계형 데이터베이스는 테이블이 다른 테이블과 관계를 맺을 때, 외래키를 사용하여 맺을 수 있습니다.
<br><br>
#### 🤔 테이블 간의 관계는 무엇이 있고, 외래키는 무엇인가요?
테이블 간의 관계는 관계를 맺는 테이블의 수에 따라 다음과 같이 나눌 수 있습니다.

<img width="500" src="http://www.tcpschool.com/lectures/img_mysql_relationship.png">

1. 일대일(one-to-one) 관계
2. 일대다(one-to-many) 관계
3. 다대다(many-to-many) 관계

외래키는 한 테이블의 키 중에서 다른 테이블의 행(row)을 식별할 수 있는 키를 의미합니다.
<br><br>
#### 🤔 NoSQL 데이터베이스가 Relation DB에 비해 Data Update를 하는데 있어 비교적 느린 이유가 무엇인가요?
NoSQL 데이터베이스의 경우 데이터가 여러 컬렉션에 중복되어 있기 때문에, 수정해야 하는 경우 모든 컬렉션을 update 해줘야 합니다.             
하지만, Relational DB에서는 중복 데이터가 없으므로 한번만 수행하면 됩니다.
<br><br>
#### 🤔 데이터베이스의 서버 확장에 대해서 설명해주세요.
데이터베이스 서버의 확장성은 수직적 확장과 수평적 확장으로 나누어집니다.
-   수직적 확장은  단순히 데이터베이스 서버의 성능을 향상시키는 것입니다.(ex. CPU 업그레이드)
-   수평적 확장은 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미합니다.

수평적 확장은 NoSQL DB에서만 가능합니다.          
데이터 저장 방식으로 인해 Relational DB는 일반적으로 수직적 확장만 지원합니다.
<br><br>
#### 🤔 Relational DB가 일반적으로 수직적 확장만 지원하는 이유는 무엇인가요?
관계형 데이터베이스를 수평적 확장하려면 샤딩이 필요합니다.        
ACID 준수를 유지하면서 관계형 데이터베이스를 샤딩하는 것은 매우 까다로운 작업이기 때문입니다.
<br><br>
#### 🤔 어떤 서비스에서 MySQL을 쓸 것 같은지?
관계형 데이터베이스를 쓰기 좋은 경우는 데이터 완전성이 무엇보다 중요한 상황입니다.        
재무 응용프로그램, 방어 및 보안, 개인 건강 정보가 대표적이고       
이밖에 고도로 정형화된 데이터, 내부 프로세스의 자동화에도 이 데이터베이스가 적합합니다.
<br><br>
#### 🤔 어떤 서비스에 MongoDB가 적합한지?
NoSQL DB는 수평으로 확장이 가능하기에, 막대한 양의 데이터를 다뤄야하는 경우와            
정확한 데이터 구조를 알 수 없을 경우(데이터 구조 변경/확장)에 적합합니다.       
상품 사용기나 블로그 댓글 등 비정형 데이터 작업이 많은 경우와 빠른 프로토 타입 작업에 적합합니다.
<br><br>
#### 📚 유익한 자료
- [RDB부터 검색엔진까지··· 내게 꼭 맞는 DB 고르기](https://www.ciokorea.com/news/38041)

---
<br><br>

## 데이터베이스에서 index를 사용하는 이유와 장단점에 대해 설명해주세요.
### 핵심 답변
데이터베이스에서 인덱스를 사용하는 이유는 검색성능을 향상시키기 위함입니다.       
인덱스는 데이터와 데이터의 위치를 포함한 자료구조이며, 찾고자하는 데이터의 위치를 빠르게 찾아주는 역할을 합니다.     

하지만 검색성능을 실질적으로 향상시키기 위해서는          
해당 쿼리가 index를 사용하는지, 카디널리티, Selectivity 같은 요소들이 고려된 인덱스가 생성되어야 합니다.
  
일반적인 경우의 장점으로는 빠른 검색 성능을 들 수 있습니다.      
일반적인 경우의 단점으로는 인덱스를 구성하는 비용 즉, 추가, 수정, 삭제 연산시에 인덱스를 형성하기 위한 추가적인 연산이 수행됩니다.       
따라서, 인덱스를 생성할 때에는 트레이드 오프 관계에 놓여있는 요소들을 종합적으로 고려하여 생성해야합니다.
<br><br>
#### 🤔 추가적인 연산이 필요한 이유는 무엇인가요?
index 트리 자료구조는 값이 추가 혹은 삭제될 때마다, 트리 균형을 위해 트리 구조의 재분배 및 합병 등 연산이 수반됩니다.        
따라서 데이터 갱신보다는 조회에 주로 사용되는 컬럼에 index를 생성하는 것이 유리합니다.
<br><br>
#### 🤔 데이터베이스에서 index를 만들면 내부적으로 어떤동작이 이루어지는지 설명해주세요.
1. 인덱스를 만들면, 인덱스 테이블이 생성되고, 인덱스 테이블은 `컬럼의 값`과 `해당 레코드가 저장된 주소`를 `key`와 `value`로 갖게 됩니다. 
<br>이 때, 생성된 테이블은 일반적으로 정렬된 B TREE의 구조를 갖게 됩니다. 
2. 인덱스를 참조할 경우 이진탐색과 key의 범위를 바탕으로 해당 key의 value가 존재하는 노드를 찾아냅니다.
3. 인덱스에서 찾은 주소를 바탕으로 테이블에서 값을 조회합니다.
<br><br>
#### 🤔 데이터베이스에서 index를 만들면 성능이 빨라지게 되는 이유를 설명해주세요.
인덱스는 데이터와 데이터의 위치를 포함한 자료구조이기에, 인덱스를 생성하면 데이터를 빠르게 조회할 수 있습니다.      

인덱스가 없을 경우 특정 데이터를 찾기 위해서는 테이블을 풀 스캔해야 하기 때문에 시간 복잡도가 O(N)을 갖습니다.     
index 트리 자료 구조는 이진 탐색을 바탕으로 데이터 위치를 조회하기 때문에 시간 복잡도가 O(logN)을 갖습니다.     

인덱스를 활용하면, 데이터를 조회하는 `SELECT` 외에도 `UPDATE` 나 `DELETE` 의 성능이 함께 향상됩니다.          
그러한 이유는 해당 연산을 수행하려면 해당 대상을 조회해야만 작업을 할 수 있기 때문입니다.

```sql
--  Joy라는 이름을 업데이트 해주기 위해서는 Joy을 조회해야 한다. 
UPDATE USER SET NAME = 'Hyeyoung' WHERE NAME = 'Joy';
```
<br>

#### 🤔 hash index를 사용했을 때의 단점과 이유를 설명하세요.
해시 테이블에서는 특정 기준보다 크거나 작은 값을 찾을 때 매우 비효율적이라는 단점이 존재합니다.            

해시 테이블은 해시 함수를 통해 나온 해시 값을 이용하여 저장된 메모리 공간에 한 번에 접근을 하기 때문에 평균적으로 O(1)이라는 시간 복잡도를 가집니다.              

그러나 이는 '단 하나의 데이터를 탐색하는 시간' 에만 O(1)입니다.             
DB에서 등호(=) 뿐 아니라 부등호(<, >)도 사용할 수 있습니다.

모든 값이 정렬되어있지 않으므로, 해시 테이블에서는 특정 기준보다 크거나 작은 값을 찾을 때 매우 비효율적입니다.
<br><br>
#### 🤔 인덱스에 왜 해쉬 보다 B Tree를 사용하나요?
해시 테이블은 하나의 데이터를 찾는 것은 빠르지만, 모든 값이 정렬되어있지 않으므로 부등호 연산에는 빠르지 않습니다.    
B Tree는 항상 정렬된 상태에 있기 때문에 특정 값보다 크고 작은 부등호 연산에도 빠릅니다.   
또한, 데이터 탐색뿐 아니라, 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가지기 때문에
DB 인덱스 자료구조로 B Tree를 많이 사용합니다.
<br><br>
#### 🤔 index 대상 컬럼 선장할 때 기준
일반적으로 Cardinality가 높은 컬럼을 우선적으로 인덱싱하는 것이 검색 성능에 유리합니다.      
Cardinality란 특정 데이터 집합의 유니크(Unique)한 값의 개수를 의미합니다.     

남-여 등 2가지 값만 존재하는 성별 컬럼은 중복도가 높으며 카디널리티가 낮고,        
개인마다 고유한 값이 존재하는 주민번호 컬럼은 중복도가 낮으며 카디널리티가 높습니다.            
Cardinality 높은 컬럼의 경우, Index를 통해 데이터를 더 많이 필터링할 수 있기 때문에 해당 컬럼을 우선적으로 인덱싱하는 것이 검색 성능에 유리합니다.
<br><br>
#### 📚 유익한 자료
- [How Does Indexing Work](https://chartio.com/learn/databases/how-does-indexing-work/)
- [B - Tree Data structure](http://www.btechsmartclass.com/data_structures/b-trees.html)
- [위키백과 - B+ 트리](https://ko.wikipedia.org/wiki/B%2B_%ED%8A%B8%EB%A6%AC)
- [DB 인덱스(INDEX) 자료구조](https://junhyunny.github.io/information/data-structure/db-index-data-structure/)
- [Binary Search Tree에서 B+Tree까지(Database Index 추가)](https://velog.io/@jewelrykim/Binary-Search-Tree%EC%97%90%EC%84%9C-BTree%EA%B9%8C%EC%A7%80Database-Index-%EC%B6%94%EA%B0%80)

---
<br><br>

## 트랜잭션이 무엇인가요.
### 핵심 답변
트랜잭션은 하나의 논리적 작업 단위를 구성하는 일련의 연산들의 집합을 말합니다.                
트랜잭션의 예로 게좌 간의 자금 이체가 많이 언급됩니다.             
한 계좌에서 10만원을 인출하면 다른 계좌로 10만원 입금하는 이체 작업은 전체 작업이 정상적으로 완료되거나,           
만약 정상적으로 처리될 수 없는 경우에는 아무 것도 실행 되지 않는 처음 상태로 되돌려져야 합니다.         
이러한 트랜잭션은 다양한 데이터 항목들을 접근하고 갱신하는 프로그램의 수행의 단위가 됩니다.
<br><br>
#### 🤔 트랜잭션의 특성에 대해 설명해주세요(ACID)
ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질입니다.

- Atomicity(원자성) : 트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 아니면, 전혀 어떠한 연산도 수행되지 않은 상태를 보장해야 합니다. 
- Consistency(일관성) : 트랜잭션이 진행되는 동안에 데이터베이스가 변경되더라도 업데이트된 데이터베이스로 트랜잭션이 진행되는 것이 아닌 트랜잭션이 진행하기 전 참조한 데이터베이스로 진행되어야 합니다.
- Isolation(독립성) : 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행되어야 합니다.
- Durability(지속성) : 트랜잭션이 성공적으로 완료되어 커밋되고 나면, 해당 트랜잭션에 의한 모든 변경은 향후에 어떤 소프트웨어나 하드웨어 장애가 발생되더라도 보존되어야 합니다.
<br><br>
###### 트랜잭션이 독립적으로 실행된다는 말은 무엇인가요?
하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없고            
수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다는 것을 말합니다.
<br><br>
###### 트랜잭션 수행이 보존해야 할 일관성은 무엇이 있을까요?
기본 키, 외래 키 제약과 같은 명시적인 무결성 제약 조건들뿐만 아니라,        
자금 이체 예에서 두 계좌 잔고의 합은 이체 전후가 같아야 한다는 사항과 같은 비명시적인 일관성 조건들도 있습니다.
<br><br>
#### 🤔 트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해주세요.
트랜잭션 격리수준은 고립도와 성능의 트레이드 오프를 조절합니다.

- READ UNCOMMITTED: 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있습니다.
  -  따라서 오염된 읽기, 재현 불가한 읽기, 허상 읽기 문제가 발생할 가능성이 있습니다.
- READ COMMITTED: 다른 트랜잭션에서 커밋된 내용만 참조할 수 있습니다.
  - 이로써 오염된 값 읽기 문제는 해결되지만 재현 불가한 읽기, 허상 읽기 문제는 여전히 남습니다.
- REPEATABLE READ: 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있습니다.
  -  오염된 값 읽기, 재현 불가한 읽기 문제는 해결되지만 허상 읽기는 여전히 남습니다.
- SERIALIZABLE: 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 합니다. 동시성 문제는 모두 해소되지만 성능이 매우 떨어집니다. 

Durty Read, Nonrepeatable Read와 같은 문제를 예방하려면 트랜잭션을 서로 완전히 격리 하면 되겠지만            
그렇게 하면 트랜잭션을 한 줄로 세워놓고 하나씩 실행하는 꼴이라서 엄청난 성능 저하가 옵니다.                
그래서, 성능을 감안하며, 요건을 충족하는 가장 낮은 수준의 트랜잭션 격리 수준을 선택하는게 좋습니다.
<br><br>
#### 🤔 트랜잭션 안에서 발생할 수 있는 문제
이름 | 설명
---|---
오염된 읽기 <br>Duty Read | T2가 수정후 커밋하지 않은 필드를 T1이 읽는 상황에서<br> **나중에 T2가 롤백되면 T1이 읽은 필드를 일시적인 값으로 더이상 유효하지 않습니다.**
재현 불가한 읽기 <br>Nonrepeatable Read | 어떤 필드를 T1이 읽은 후 T2가 수정할 경우, <br>**T1이 같은 필드를 다시 읽으면 다른 값을 얻습니다.**
허상 읽기 <br>Phantom Read | T1이 테이블의 로우를 몇개를 읽은 후 T2가 같은 테이블에 새 로우를 삽입할 경우, <br>나중에 T1이 같은 테이블을 다시 읽으면 T2가 삽입한 로우가 보입니다.
소실된 수정 <br>Lost Update | T1, T2가 모두 어떤 로우를 수정하려고 읽고 그 로우의 상태에 따라 수정하는 경우입니다. <br>T1이 먼저 로우를 수정 후 커밋하기 전, <br>T2가 T1이 수정한 로우를 똑같이 수정했다면 T1이 커밋한 후에 T2 역시 커밋하게 됩니다. <br>그러면 **T1이 수정한 로우를 T2가 넢어쓰게 되어 T1이 수정한 내용이 소실됩니다.**
<br>

#### 🤔 트랜잭션 잠금에 대해서 설명해주세요.
<br><br>
#### 🤔 잠금 타임아웃과 교착 상태가 발생하는 이유에 대해서 설명해주세요.
<br><br>
#### 🤔 트랜잭션 Rollback은 어떤 경우에 하나요?
하나의 트랜잭션 처리가 비정상적으로 종료되면 트랜잭션의 원자성을 위해 롤백을 사용합니다.     
트랜잭션을 사용해 데이터를 추가하다 에러가 발생할 때,    
트랜잭션을 롤백함으로써 해당 트랜잭션에서 작업한 모든 연산을 취소하여 실제 데이터베이스에 반영하지 않도록 합니다.       
롤백하고 난 후에는 해당 트랜잭션을 재시작하거나 폐기해야 합니다.
<br><br>
#### 📚 유익한 자료

---
<br><br>

## Elastic Search에 대해서 간단히 설명해주세요.
### 핵심 답변
Elastic Search는 자바로 개발된 오픈소스 검색엔진 입니다.          
보통 단독으로 사용하기보다는 ELK 스택이라고 부르는 Logstash, Kibana, Beats를 추가적으로 사용합니다.             
Inverted Index 구조로 데이터를 저장해서, 전문(Full-text) 검색시에 RDBMS에 비해 뛰어난 성능을 보장합니다.               
다양한 용도로 사용할 수 있습니다. (데이터 저장, 문서 검색, 위치 검색, 머신 러닝 기반 검색, 로그 분석, 보안 감사 분석 등)
<br><br>
#### 🤔 Elastic Search의 인덱스구조와 RDBMS의 인덱스 구조의 차이에 대해 설명해주세요.
Elastic Search는 Inverted-Index 구조로 데이터를 저장합니다.        
이는 책의 색인을 생각해보면 쉬운데, 특정 단어가 출현하는 doc을 저장하는 것입니다.          
반면 RDBMS는 B-Tree와 그와 유사한 인덱스를 사용합니다. 데이터가 어디에 존재하는지 어떤 순서로 저장하는 지의 차이라고 생각합니다.       
RDBMS에도 다양한 인덱스 구조가 있으나 여기서 예로 든 것은 B-Tree 인덱스입니다.
<br><br>
#### 🤔 Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.
Elastic Search의 키워드 검색은 document를 저장할 때 수행하는 알고리즘과 동일한 알고리즘으로 키워드를 분리합니다.           
그 중에서 랭킹알고리즘을 통해서 가장 유사한 순서대로 결과를 나타냅니다.          
RDBMS에서의 LIKE 검색은 와일드카드로 시작하지 않는 경우에만 인덱스를 사용하고 나머지 경우는 전체를 탐색하기 때문에 상대적으로 느립니다.
<br><br>
#### 🤔 역인덱싱에 대해 자세히 설명해주세요.
역인덱싱은 대용량 텍스트의 효율적인 검색을 위해 고안된 방법으로         
문서를 유의미한 단어로 분리하여 정렬된 목록을 작성한 후에, 각 단어가 어느 문서에 있는지 표시하여 작성하는 작업입니다.         
이 방법은 단어들이 이미 정렬되어 있기 때문에 검색 및 탐색의 속도가 매우 빠릅니다.     

이 때 문서를 유의미한 단어로 분리하기 위해 형태소 분석 과정을 거칩니다.
<br><br>
#### 📚 유익한 자료
- [Inverted Index](https://esbook.kimjmin.net/06-text-analysis/6.1-indexing-data)
---
<br><br>

## 정규화에 대해서 설명해주세요.
정규화는 데이터의 중복 방지와 데이터에서 일어날 수 있는 이상 현상을 방지를 위해 데이터베이스를 설계하는 것을 의미합니다.        
정규화를 거치면, 크고 제대로 조직되지 않는 테이블들을 작게 나누면서 데이터의 중복을 없애고 잘 조직된 구조로 만들어지게 됩니다.
<br><br>
#### 🤔 제 1, 2, 3 정규화에 대해서 설명하세요.
###### 제 1정규화      
제 1정규화는 테이블의 각 속성이 복합적인 값을 포함하지 말아야 합니다.              
요즘 쓰이는 RDBMS에서는 테이블을 만들 때 각 칼럼이 원자적인 속성일 것을 강제하기 때문에 지켜지지 않는 경우가 거의 없습니다.       
또한, 중복되는 항목이 없어야 하고, 기본 키로 각 행을 식별할 수 있어야 합니다.

###### 제 2정규화      
제 2정규화는 제 1정규화를 만족하면서, 하나의 속성으로만 후보 키로 사용하는 것입니다.          
후보키란 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합입니다.

<img width="400" alt="스크린샷 2022-02-14 21 43 36" src="https://user-images.githubusercontent.com/29566893/153866915-ecf6496f-0675-408d-b5ed-416f3b056517.png">

위 테이블은 종업원과 기술 두 속성을 모두 사용해야 후보 키로 쓸 수 있습니다.        
즉, 후보키는 {종업원, 기술}입니다.       
그러나, 근무지 속성은 종업원 속성에만 종속되어 있으며, 근무지 속성은 중복됩니다.      
이 테이블에서는 Jones의 근무지를 갱신할 때, Typing, Shorthand에 대한 근무지만 갱신될 수 있는 위험이 있습니다.

<img width="400" alt="스크린샷 2022-02-14 21 43 45" src="https://user-images.githubusercontent.com/29566893/153866920-b76a24da-89de-497c-be9a-e5363a6be023.png">

제 2정규화를 만족시키기 위해, 기존 테이블을 분해한 예시 입니다.       
이 구조에서는 갱신 이상이 발생하지 않습니다.       
그러나, 제 2정규화를 만족시키는 모든 테이블이 갱신 이상이 없는 것은 아닙니다.

###### 제 3정규화
제 3정규화는 제 2정규화를 만족하면서, 모든 속성이 기본 키에 대해서만 의존되어야 합니다.     
이 조건은 자연히 추이 종속성이 발생하지 않을 것을 요구합니다.

<img width="400" alt="스크린샷 2022-02-14 21 44 27" src="https://user-images.githubusercontent.com/29566893/153866928-ca52aef4-3d7b-491f-a1fc-e051008a5e03.png">
<img width="400" alt="스크린샷 2022-02-14 21 44 41" src="https://user-images.githubusercontent.com/29566893/153866930-e906ff1b-e90f-482b-a29e-7686f5a0fd31.png">

위의 테이블의 경우 기본 키에 의해서만 모든 속성이 결정됩니다.         
대회 우승자 테이블은 {대회, 연도}가 기본 키이고, 우승자 생년 월일 테이블은 {우승자}가 기본키입니다.     
제 3정규화 에서는 갱신 이상이 덜 발생합니다.
<br><br>
#### 🤔 잘 조직되지 않는 테이블에서 일어날 수 있는 이상들은 무엇인가요?
대표적 이상은 삽입 이상과 삭제 이상과 갱신 이상입니다.         
삽입 이상은 관계에 데이터를 삽입할 때 의도와 상관없이 원하지 않는 값들도 함께 삽입되는 현상입니다.        
삭제 이상은 관계에 데이터를 삭제할 때 의도와 상관없는 값들도 함께 삭제되는 현상입니다.       
갱신 이상은 관계의 행에 있는 속성 값을 갱신할 때 일부 행의 데이터만 갱신되어 데이터에 모순이 생기는 현상입니다.        
정규화를 거치면, 위의 이상들이 일어나지 않도록 할 수 있습니다.        
또한, 현실적으로 과도한 정규화는 DB 질의 처리 속도를 떨어 뜨리기 때문에 제 3 정규화 또는 보이스 코드 정규화까지만 정규화를 진행하며, 필요에 따라 비정규화 작업을 하기도 합니다.
<br><br>
#### 🤔 Denormalization은 무엇이고, 언제 시행하게 되는지 설명해주세요.
비정규화는 정규화의 반대 개념으로, 중복 데이터를 허용하는 것입니다. 비정규화는 성능을 상당히 개선시킬 수 있기 때문에 사용합니다.     
데이터가 비정규화되면 테이블을 여러 개씩 읽을 필요도 없고 여러 컬렉션에 있는 데이터에 조인을 수행할 필요도 없습니다.      
대신 단일 컬렉션이나 문서에서 데이터를 읽으면 됩니다.    
이렇게 하면, 특히 인덱스를 사용할 수 있을 때 컬렉션 여러 개에서 데이터를 추출하는 것보다 훨씬 속도가 빠릅니다.
<br><br>
#### 📚 유익한 자료
- [개념 정리 - (9) 데이터베이스 편](https://brunch.co.kr/@toughrogrammer/17)
- [비정규화](https://thebook.io/006765/part03/ch07/03/02/)

---
<br><br>
## JPA란?
### 핵심답변
JPA란 Java Persistance API의 약자로 JAVA ORM 표준 기술입니다.
<br><br>
#### 🤔 ORM이란 무엇인가요
객체와 관계형 데이터베이스를 매핑해주는 것으로 쿼리문 작성 없이 객체를 데이터베이스에 직접 저장할 수 있게 도와주는 기술입니다.
<br><br>
#### 🤔 JPA를 사용할 때의 이점에 대해서 설명해주세요.
JPA가 있다면, 자바 언어로 구현하다가, 갑자기 SQL로 구현해주지 않아도 됩니다.       
JPA를 통해 SQL을 자바로 만들 수 있고, 그 결과 유지보수가 쉽습니다.

JPA를 사용하지 않았을 때는 필드 변경 시, 모든 SQL을 수정해야 했습니다.      
하지만, JPA를 사용했을 때는 필드가 변경 시, 필드만 변경해주면 됩니다. SQL은 JPA가 처리하기 때문에 손댈 것이 없습니다.
<br><br>
#### 🤔 JPA, Hibernate 그리고 Spring Data JPA 각각에 대해서 설명해주세요.
<img width="500" src="https://suhwan.dev/images/jpa_hibernate_repository/overall_design.png">

###### JPA
JPA는 기술 명세입니다.            
자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스입니다.        
예를 들어, JPA의 핵심이 되는 EntityManager는 아래와 같이 javax.persistence.EntityManager 라는 파일에 interface로 정의되어 있습니다.
```java
package javax.persistence;

import ...

public interface EntityManager {

    public void persist(Object entity);

    public <T> T merge(T entity);

    public void remove(Object entity);

    public <T> T find(Class<T> entityClass, Object primaryKey);

    // More interface methods...
}
```

###### Hibernate
Hibernate는 JPA의 구현체입니다.     
javax.persistence.EntityManager와 같은 인터페이스를 직접 구현한 라이브러리입니다.

###### Spring Data JPA
Spring Data JPA는 Spring에서 제공하는 모듈 중 하나로, 개발자가 JPA를 더 쉽고 편하게 사용할 수 있도록 도와줍니다.            
이는 JPA를 한 단계 추상화시킨 Repository라는 인터페이스를 제공함으로써 이루어집니다.           
사용자가 Repository 인터페이스에 정해진 규칙대로 메소드를 입력하면,        
Spring이 알아서 해당 메소드 이름에 적합한 쿼리를 날리는 구현체를 만들어서 Bean으로 등록해줍니다.
<br><br>
#### 🤔 JPA가 클래스가 아닌 인터페이스를 사용하는 이유에 대해서 설명해주세요.
상속을 통해, 코드를 재사용한다면, 부모클래스를 상속받은 자식클래스에서는 부모 클래스의 모든 메서드를 그대로 사용할 수 있기에, 캡슐화를 위반합니다.       
또한, 원치 않은 메서드들도 상속됩니다. 원치 않은 메서드도 상속되면 의도치 않은 버그도 발생시킬 수 있습니다.

인터페이스를 사용하면, 함수의 특징만을 정의하고 함수의 내용이 없기에 결합도가 낮습니다.       
클래스의 기본 틀을 제공하여 정의된 메서드를 통해서만 코드를 재사용할 수 있기에, 개발자들에게 정형화된 개발을 할 수 있게 해줄 수 있습니다.
<br><br>
#### 🤔 데이터 정합성에 대해서 설명해주세요. JPA에서 이것들을 어떻게 처리하는가요?
<br><br>
#### 🤔 DB Lock에 대해서 설명해주세요. JPA에서 이것들을 어떻게 처리하는가요?
<br><br>
#### 📚 유익한 자료
- [JPA, Hibernate, 그리고 Spring Data JPA의 차이점](https://suhwan.dev/2019/02/24/jpa-vs-hibernate-vs-spring-data-jpa/)

---
<br><br>
# Web
## 쿠키와 세션에 대해서 설명해주세요.
### 핵심 답변
- 쿠키
  - 쿠키는 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일입니다.
  - 이름, 값, 만료 날짜/시간(쿠키 저장기간), 경로 정보 등을 포함하고 있습니다.
  - 클라이언트의 상태 정보를 브라우저에 저장했다가 요청할 때, 참조됩니다.
- 세션
  - 세션은 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술입니다. 
  - 즉, 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태입니다.
  - 상태를 유지하기 유지하는 수단이 쿠키이며, 사용자 정보를 서버측에서 관리함으로써 상태를 유지합니다.
<br><br>
#### 🤔 쿠키와 세션의 필요성은 무엇일까요?
HTTP 프로토콜의 경우, 현재 접속한 사용자가 이전에 접속했던 사용자와 같은 사용자인지 알 수 있는 방법이 없습니다.      
하지만, 이전 요청과 현재 요청이 같은 사용자의 요청인지 알아야 되는 상황이 있습니다.    

대표적으로 장바구니 기능을 사용한 경우입니다.      
장바구니 기능의 경우 상태유지가 되지 않으면,     
상품을 장바구니 담기를 클릭했는데, 장바구니 페이지에는 선택한 상품의 정보가 없는 일이 발생할 수가 있습니다.

이를 위해서는 상태를 유지해야 하고, HTTP 프로토콜에서 상태를 유지하기 위한 기술로 쿠키와 세션이 있습니다.
<br><br>
#### 🤔 쿠키와 세션의 동작방식에 대해서 설명해주세요.
###### 쿠키
<img width="350" src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FBjzmc%2FbtrqOgQpvN5%2FvBaLMopSvroTlGorOoANCK%2Fimg.png">

1. 웹 브라우저가 서버에 요청
2. 상태를 유지하고 싶은 값을 쿠키로 생성
3. 서버가 응답할 때, HTTP 헤더(Set-Cookie)에 쿠키를 포함해서 전송
> Set−Cookie: id=doy
4. 전달받은 쿠키는 웹브라우저에서 관리하고 있다가, 다음 요청 때 쿠키를 HTTP 헤더에 넣어서 전송
> Set−Cookie: id=doy
5. 서버에서는 쿠키 정보를 읽어 이전 상태 정보를 확인한 후 응답
<br><br>
###### 세션
<img width="480" src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdjd2G8%2FbtrqOhod6mQ%2Fm8f0KkjaHKbMCOkkrbxd5K%2Fimg.png">

1. 웹브라우저가 서버에 요청합니다.
2. 서버가 해당 웹브라우저(클라이언트)에 유일한 ID (Session ID)를 부여합니다.
3. 서버가 응답할 때 HTTP헤더(Set-Cooke)에 Session ID를 포함하여 전송하여,<br>
   쿠키에 Session ID를 JSESSIONID라는 이름으로 저장합니다.
> Set−Cookie: JSESSIONID=xslei13f
4. 웹브라우저는 이후 웹브라우저를 닫기까지, 다음 요청 때, 부여된 SessionID가 담겨있는 쿠키를 HTTP 헤더에 넣어서 전송합니다.
> Cookie: JSESSIONID=xslei13f
5. 서버는 세션 ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답합니다.
<br><br>
#### 🤔 쿠키와 세션은 언제 사용하나요?
- 쿠키는 클라이언트에 저장 되므로, 보안에 취약합니다. 그러므로 로그인에는 잘 쓰이지 않습니다.
<br>아이디 저장, 쇼핑몰 장바구니에 사용됩니다.
- 세션은 쿠키를 이용해 Session ID만 클라이언트에 저장하고 이 값으로 구분해서 서버에서 처리하므로 쿠키보다 비교적 보안성이 좋습니다.
<br>보안이 중요한 로그인에 사용됩니다.
<br><br>
#### 📚 유익한 자료
- [쿠키와 세션](https://doooyeon.github.io/2018/09/10/cookie-and-session.html)
---
<br><br>
## 세션 기반 인증 방식과 토큰 기반 인증 방식의 차이점에 대해서 설명해주세요.
### 핵심 답변
<br><br>
#### 🤔 세션 기반 인증 방식과 토큰 기반 인증 방식의 동작방식에 대해서 설명해주세요.
<br><br>
#### 🤔 세션 기반 인증 방식과 토큰 기반 인증 방식의 장단범은 무엇인가요?
<br><br>
#### 📚 유익한 자료

---
<br><br>
## JWT에 대해서 간단히 설명해주세요.
### 핵심 답변
<br><br>
#### 🤔 JWT를 사용한 이유와 장점은 무엇인가요?
토큰 기반 인증 방식을 사용한 이유는 확장성이 좋기 때문입니다. 클라이언트가 토큰 정보를 갖고 있기 때문에 서버 확장하는데 부담이 적습니다.  
또한, 토큰 기반 인증 방식은 다양한 도메인에 관리하기가 쉽습니다.   
(세션을 관리할 때 자주 사용되는 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 있지만, 토큰은 어떤 도메인에서도 토큰의 유효성 검사를 진행한 후에 요청을 처리할 수 있습니다.)     
토큰 기반 인증 방식 중 JWT를 쓴 이유는 JSON은 인코딩했을 시 XML 보다 간결하며 사이즈도 작습니다. 따라서 JWT를 HTTP, HTML 환경에서 전달하는 것은 좋은 선택입니다.    
또한, JSON 파서는 보통 대부분의 프로그래밍 언어에서 객체와 직접 매핑됩니다. 반대로 XML은 자연스러운 문서-객체 매핑이 없습니다. 따라서 JWT 작업이 다른 토큰 기반 인증 방식보다 쉽습니다.
<br><br>
#### 🤔 JWT 단점은 무엇인가요?
- 토큰 자체에 정보를 담고 있으므로 양날의 검이 될 수 있습니다.
- 토큰의 페이로드(Payload)에 3종류의 클레임을 저장하기 때문에, 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있습니다.
- 페이로드 자체는 암호화 된 것이 아니라, BASE64로 인코딩 된 것입니다. 중간에 Payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로, JWE로 암호화하거나 Payload에 중요 데이터를 넣지 않아야 합니다.
- JWT는 상태를 저장하지 않기 때문에 한번 만들어지면 제어가 불가능합니다. 즉, 토큰을 임의로 삭제하는 것이 불가능하므로 토큰 만료 시간을 꼭 넣어주어야 합니다.
<br><br>
#### 🤔 
#### 📚 유익한 자료
- [JWT 공식 문서](https://jwt.io/introduction/)
- [JWT(Json Web Token)란?](https://mangkyu.tistory.com/56)

---
<br><br>
## 웹 서버와 WAS의 차이점에 대해서 설명해주세요.
### 핵심 답변
웹서버는 HTTP 요청을 받아들이고 HTML, 이미지 파일, CSS 같은 문서 또는 리소스 데이터를 반환하는 역할을 하는 프로그램입니다.    
대표적인 웹서버는 Ngnix, Apache가 있습니다.    
WAS는 웹 어플리케이션을 실행하여 동적으로 서버 컨텐츠를 생성하는 역할을 담당하는 미들웨어 입니다.    
대표적인 WAS로는 아파치 톰켓, 웹로직, 제이보스 등이 있습니다.

즉, 웹서버는 HTML, 이미지, CSS 등의 정적인 리소스를 전달하는 역할을 한다면,    
WAS는 동적으로 동작하며 DB와 연동되고 비즈니스 로직을 포함합니다.
<br><br>
#### 📚 유익한 자료
[웹서버, WAS 개념 정리](https://brunch.co.kr/@springboot/21)

---
<br><br>
## SQL Injection에 대해서 간단히 설명해주세요.
### 핵심 답변
<br><br>
#### 📚 유익한 자료

---
<br><br>
## REST란 무엇이며, 이것에 대해서 아는대로 설명해보세요.
### 핵심 답변
RESTful운 REST 원리를 따르는 시스템으로 REST 특징을 지키면서 API를 제공하는 것입니다.       
이 용어는 REST는 웹의 창시자(HTTP) 중의 한 사람인 Roy Fielding의 2000년 논문에서 소개되었습니다.      
현재의 아키텍처가 웹의 본래 설계의 우수성을 많이 사용하지 못하고 있다고 판단했기 때문에,      
웹의 장점을 최대한 활용할 수 있는 네트워크 기반의 아키텍처를 소개했는데 그것이 바로 Representational safe transfer (REST)입니다.       
웹에 존재하는 모든 자원(이미지, 동영상, DB)에 고유한 URI를 부여해 활용 하는 것입니다.
<br><br>
###### 용어 정리
- 리소스(Resource): 데이터의 일부입니다. (ex. user)
- 콜렉션(Collection): 리소스의 집합입니다. (ex. users)
- URL(Identifies the location): 리소스 혹은 콜렉션을 식별할 수 있는 경로입니다. (ex./company/google/employee/12)
<br><br>
#### 🤔 본인이 프로젝트를 진행할때 Restful API를 지키기위해 한 노력은 무엇인가요?
- HTTP METHOD를 통해서 CRUD 중 무엇을 수행하는지 알 수 있게 했습니다.
  - POST = 새로운 리소스를 생성합니다.
  - GET = 리소스 정보를 조회합니다.
  - PUT = 존재하는 리소스 수정합니다.
  - PATCH = 제공된 리소스를 업데이트합니다. 제공된 필드만 업데이트하고 나머지 필드는 그대로둡니다.
  - DELETE = 존재하는 리소스를 삭제합니다.
- Collection에는 단수가 아닌 복수를 사용했습니다.
  - Bad
    - [GET] /user
    - [GET] /User
  - Good
    - [GET] /users
- Collection으로 시작해서 Identifier로 끝냈습니다.
  - Bad
    - GET /shops/{shopId}/category/{categoryId}/price
  - Good
    - GET /shops/{shopId} 
    - GET /category/{categoryId}
- URL에는 동사보다 명사를 사용했습니다.
  - Bad
    - [POST] /updateuser/{userId}
    - [GET] /getusers
    - 행위를 URL에 붙인 경우 좋지 못합니다.
  - Good:
    - [PUT] /user/{userId}
- 또한, URI 설계시 아래의 기준으로 변경했습니다.
  - /관련 DB Columns/관련 Field값
    - ex) sign up → POST /users/2
  - /는 계층관계를 나타냄, 큰 범위/작은 범위
    - ex) /tils/like/idx
  - /리소스명/리소스 ID/관계가 있는 다른 리소스명
    - ex) my til delete → /users/{userid}/tils/idx
<br><br>
#### 📚 유익한 자료
- [REST API 제대로 알고 사용하기](https://meetup.toast.com/posts/92)

---
<br><br>
# Network
## 웹 브라우저에서 URI에 구글닷컴을 쳤을 때 발생하는 일들을 아는 대로 설명해주세요.
### 핵심 답변
#### DNS 서버, HTTP 프로토콜(80포트), HTTPS 프로토콜(443포트), DOM, IP, PORT 등등의 용어를 사용해서
브라우저가 URL에 적힌 값을 파싱해서 HTTP Request Message를 만들고, OS에 전송 요청을 합니다.      
이 때, Domain으로 요청을 보낼 수 없기 때문에 DNS Lookup을 수행합니다.

DNS 룩업 과정은 크롬의 경우 브라우저 → hosts 파일 → DNS Cache의 순서로 도메인에 매칭되는 ip를 찾습니다.        
DNS Lookup은 루트 도메인서버에서부터 서브도메인 서버순으로 찾게됩니다.

이 요청은 프로토콜 스택이라는 OS에 내장된 네트워크 제어용 소프트웨어에 의해 패킷에 담기고 패킷에 제어정보를 덧붙여 LAN 어댑터에 전송하고,        
LAN 어댑터는 이를 전기신호로 변환시켜 송출합니다.

패킷은 스위칭 허브 등을 경유하여 인터넷 접속용 라우터에서 ISP로 전달되고 인터넷으로 이동합니다.       
액세스 회선에 의해 통신사용 라우터로 운반되고 인터넷의 핵심부로 전달됩니다. 고속 라우터들 사이로 목적지까지 패킷이 흘러들어가게 됩니다.

핵심부를 통과한 패킷은 목적지의 LAN에 도착하고, 방화벽이 패킷을 검사한 후 캐시 서버로 보내어 웹 서버에 갈 필요가 있는지 검사합니다.

웹 서버에 도착한 패킷은 프로토콜 스택이 패킷을 추출하여 메시지를 복원하고 웹 서버 애플리케이션에 넘깁니다.        
애플리케이션은 요청에 대한 응답 데이터를 작성하여 클라이언트로 회송하고, 이는 전달된 방식 그대로 전송됩니다.
<br><br>
#### 🤔 
<br><br>
#### 📚 유익한 자료

---
<br><br>
## 사용자가 웹브라우저를 통해 서버에 이미지를 요청해서 사용자에게 보여주기까지 과정을 설명하세요.
### 핵심 답변
1. 웹 브라우저가 https://www.google.com/images/google.png로 이미지를 요청 해야 한 다는 것을 인지한다.
2. 웹 브라우저는 URL을 이용해 서버의 IP를 추출한다. 
   - DHCP 서버에서 자신의 IP주소, 가까운 라우터 IP, 가까운 DNS 서버 IP 수신
   - DNS 서버에 요청해서 URL에 해당하는 IP 주소를 수신한다 
     - 통신사별 DNS -> Root 네임서버 -> .com 네임버서로 단계별 DNS query
     - DNS서버도 계층화 되어있다(최상단 DNS서버 전세계 13개)
   - IP주소를 받은 후, ARP를 통해 해당 IP주소의 MAC주소를 추적한다
     - LAN일 경우, 라우팅 테이블에서 찾고
     - 아닐 경우, Gateway 통해 밖으로 나가 해당 MAC 주소를 찾아낸다
3. 웹브라우저는 서버와 TCP 커넥션을 맺는다. (3-way-handshaking)
   - Client는 SYN(a) 패킷을 보낸다.
   - Server는 응답으로 ACK(a+1)과 포트를 열라는 SYN(b)를 보낸다.
   - Client는 응답으로 ACK(b+1)를 보내며 연결이 성립된다.
4. 이미지를 요청하기 위한 HTTP 요청 메세지를 만든다.
   - GET Method, /google.png를 요청하는 메시지이다
5. 웹브라우저는 서버에 HTTP요청을 보낸다.
   <br>서버와 TCP 커넥션을 끊는다. (4-way-handshaking)
   - Client는 연결을 끊겠다는 FIN을 보낸다. 
   - Server는 응답으로 ACK를 보낸다. 
   - Server는 통신이 끝날때까지 기다렸다가 마치면, 연결 종료 FIN을 보낸다. (CLOSE)
   - Client는 ACK를 보낸다. 
   - Server는 Socket을 close한다. 
   - Client는 아직 전송받지 못한 데이터가 있을 것을 대비해 기다린다.(TIME_WAIT)
6. 서버는 메세지를 받고 무슨 내용인지 해석한다. Get Method /google.png
   - Httpd(Apache, Nginx..)가 요청을 수신한다.
7. 서버는 해당 Resource 있는지 찾는다.
8. 서버는 클라이언트와 TCP컨넥션을 맺는다. (3-ways-handshaking)
9. 찾으면 Status Code 200인 메세지와 함께 HTTP응답 메세지를 작성한다. 
10. 서버는 클라이언트에 HTTP 응답을 보낸다.
11. 커넥션이 닫히면 웹브라우저는 사용자에게 이미지를 보여준다.
    - 구문 분석 (HTML, CSS, JS) + 렌더링 ( DOM Tree 구성 - 렌더 트리 구성 - 렌더트리 레이아웃 배치 - 렌더트리 그리기 )
    - HTML parsing, CSS parsing, Page Rendering, GPU Rendering 을 통해 그림을 그려냄
<br><br>
#### 🤔 
<br><br>
#### 📚 유익한 자료
- [사용자가 웹브라우저를 통해 서버에 이미지를 요청해서 사용자에게 보여주기까지 과정](https://krksap.tistory.com/1148)
- [웹 브라우저에 URL을 입력하고 첫 화면이 출력되기까지](https://velog.io/@directorhwan59/%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90-URL%EC%9D%84-%EC%9E%85%EB%A0%A5%ED%95%98%EA%B3%A0-%EC%B2%AB-%ED%99%94%EB%A9%B4%EC%9D%B4-%EC%B6%9C%EB%A0%A5%EB%90%98%EA%B8%B0%EA%B9%8C%EC%A7%80)

---
<br><br>
## OSI 7계층이 무엇인지 그 존재 이유에 대해서 설명해보세요.
### 핵심 답변
OSI7계층은 네트워크 통신을 구성하는 요소들 7개의 계층으로 표준화 한 것입니다.        
이렇게 표준화하는 것의 장점은 통신이 일어나는 과정을 단계별로 파악할 수 있어, 문제가 발생하면 해당 문제를 해결하기 용이해집니다.
<br><br>
#### 🤔 TCP/IP 4계층에 대해 설명해보세요.
실제로 우리가 대부분 사용하는 네트워크 모델는 TCP/IP 4계층입니다.     
통신에 실제로 사용되는 계층이고 1,2 계층이 1계층, 5, 6, 7계층이 4계층으로 운영됩니다.

<img width="500" src="https://tecoble.techcourse.co.kr/static/76b4df259f1a2a718eaaa4515727c550/a27c6/2021-10-11-tcp-model.png">

<br>

###### 각 계층에 대해서 자세히 설명해주세요.
Application Layer는 high-level 프로토콜을 담당합니다.      
애플리케이션의 데이터 전송을 하고, 대표적인 프로토콜은 HTTP, SMTP, FTP이 있습니다. 

Transport Layer는 신뢰성, 흐름 제어, 데이터 수정을 담당합니다.      
대표적인 프로토클은 TCP, UDP가 있습니다.

Network Layer는 네트워크를 통해 패킷 전송합니다.
대표적인 프로토클은 IP, ARP, ICMP가 있습니다.

Data Link Layer는 네트워크 계층으로부터 받은 패킷 헤더에 MAC 주소 추가합니다.

Physical Layer는 모델의 최하단 계층으로써 비트 단위의 실질적인 데이터 전송 담당합니다.
<br><br>
#### 🤔 웹 서버 소프트웨어(Apache, Nginx)는 OSI 7계층 중 어디서 작동하는지 설명해보세요.
Application Layer에서 작동됩니다.      
웹 서버 소프트웨어는 HTTP 프로토콜을 이용하여 HTML, CSS, Javascript, image와 같은 정적인 정보들을 웹 브라우저에 전송합니다.      
HTTP 프로토콜은 OSI 7 계층인 Application Layer에 위치한 프로토콜로서, 브라우저(클라이언트)와 서버 사이에 정보를 주고 받기 위한 프로토콜로 사용됩니다.
<br><br>
#### 🤔 웹 서버 소프트웨어(Apache, Nginx)의 서버 간 라우팅 기능은 OSI 7계층 중 어디서 작동하는지 설명해보세요.
<br><br>
#### 📚 유익한 자료
- [네트워크의 기본 'OSI 7계층' 한번에 이해하고 외우는 방법](https://www.ciokorea.com/news/36536#csidxa7b8fb7c6c7e34a85f2253bf8c1b283)

---
<br><br>
## TCP와 UDP의 차이점에 대해서 설명해보세요.
### 핵심 답변
TCP는 연결 지향형 프로토콜이고 UDP는 데이터를 데이터그램단위로 전송하는 프로토콜입니다.

TCP는 가상 회선을 만들어 신뢰성을 보장하도록(흐름 제어, 혼잡 제어, 오류 제어) 하는 프로토콜로      
따로 신뢰성을 보장하기 위한 절차가 없는 UDP에 비해 속도가 느린편입니다.

TCP는 그래서 파일전송과 같은 신뢰성이 중요한 서비스에 사용되고,         
UDP는 스트리밍, RTP와 같이 연속성이 더 중요한 서비스에 사용됩니다.

하지만 UDP도 신뢰성을 UDP자체에서 보장하지 않는 것 뿐이지, 개발자가 직접 신뢰성을 보장하도록 할 수 있습니다.         
그래서 HTTP/3은 QUIC이라는 프로토콜을 기반으로 하는데, QUIC은 UDP를 기반으로 합니다.        
즉, UDP 자체는 신뢰성을 보장하지 않지만, 추가적인 정의를 통해 신뢰성을 보장받을 수 있습니다.
<br><br>
#### 🤔 3 way hand shake에 대해서 설명하세요.
TCP 3way handshake는 가상회선을 수립하는 단계입니다.        
클라이언트는 서버에 요청을 전송할 수 있는지, 서버는 클라이언트에게 응답을 전송할 수 있는지 확인하는 과정입니다.         

SYN, ACK 패킷을 주고받으며, 임의의 난수로 SYN 플래그를 전송하고, ACK 플래그에는 1을 더한값을 전송합니다.         
정확한 순서는 SYN(n) -> ACK(n + 1), SYN(m) -> ACK(m + 1) 순으로 일어납니다.
<br><br>
###### 🤔 왜 임의의 난수를 지정하나요? 
기존 요청과 구분하기 위해서   
더 있을까?
<br><br>
#### 📚 유익한 자료

---
<br><br>
## HTTP의 역할은 무엇인가요?
### 핵심답변
WWW(World Wide Web)에서 하이퍼텍스트(hypertext) 문서를 교환하기 위하여 사용되는 통신규약입니다.
#### 🤔 HTTP와 HTTPS의 차이를 설명하세요.
HTTP는 따로 암호화 과정을 거치지 않기 때문에 중간에 패킷을 가로챌 수 있고, 수정할 수 있습니다. 따라서 보안이 취약해짐을 알 수 있습니다.    
이를 보완하기 위해 나온 것이 HTTPS입니다. 중간에 암호화 계층을 거쳐서 패킷을 암호화합니다.
<br><br>
#### 🤔 HTTPS에 대해서 설명하고 SSL Handshake에 대해서 설명해보세요.
HTTPS는 HTTP에 보안 계층을 추가한 것입니다. HTTPS는 제3자 인증, 공개키 암호화, 비밀키 암호화를 사용합니다.           

제3자 인증은 믿을 수 있는 인증기관에 등록된 인증서만 신뢰하는 것이고,       
공개키 암호화는 비밀키를 공유하기 위해 사용합니다.       
비밀키 암호화는 통신하는 데이터를 암호화하는데 사용합니다.        

- 클라이언트는 TCP 3way handshake를 수행한 이후 Client Hello를 전송합니다.         
- 서버는 인증서를 보냅니다.      
- 클라이언트는 받은 인증서를 신뢰하기 위해서 등록된 인증기관인지 확인합니다.       
이 인증서는 인증기관의 개인키로 암호화되어있고, 공개키로 검증할 수 있습니다.     
- 클라이언트는 사이트의 정보와, 서버의 공개키를 얻을 수 있습니다.      
서버의 공개키로 통신에 사용할 비밀키를 암호화해서 서버에 보냅니다.       
- 서버는 이를 개인키로 확인하고 이후 통신은 공유된 비밀키로 암호화되어 통신합니다.
<br><br>
#### 🤔 HTTP 프로토콜의 특징
1. 비연결 지향(Connectionless) : 클라이언트가 request를 서버에 보내고, 서버가 클라이언트에 요청에 맞는 response를 보내면 바로 연결을 끊습니다.
2. 상태정보 유지 안 함(Stateless) : 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않습니다.
<br><br>
#### 🤔 HTTP 1.1 VS 2.0
HTTP/1.1는 Connection당 하나의 요청을 처리 하도록 설계 되어 있습니다.      
그래서 동시전송이 불가능하고 요청과 응답이 순차적으로 이루어 지게 됩니다.         
그렇다 보니 HTTP문서 안에 포함된 다수의 리소스 (CSS, JS, Images)를 처리하려면 요청할 리소스 개수에 비례해서 Latency(대기 시간)는 길어지게 됩니다.

HTTP/1.1 단점으로는 다음과 같습니다.
###### HOL(Head Of Line) Blocking 
###### 특정 응답의 지연, RTT(Round Trip Time) 증가
###### 무거운 Header 구조 (특히 Cookie)
<br>

HTTP/2.0 장점은 다음과 같습니다.
###### Multiplexed Streams
한 커넥션으로 동시에 여러개의 메세지를 주고 받을 있으며, 응답은 순서에 상관없이 stream으로 주고 받습니다.         
HTTP/1.1의 Connection Keep-Alive, Pipelining의 개선이라 보면 됩니다.
###### Stream Prioritization
예를 들면 클라이언트가 요청한 HTML문서안에 CSS파일 1개와 Image파일 2개가 존재하고       
이를 클라이언트가 각각 요청하고 난 후 Image파일보다 CSS파일의 수신이 늦어지는 경우 브라우저의 렌더링이 늦어지는 문제가 발생합니다.    
HTTP/2의 경우 리소스간 의존관계(우선순위)를 설정하여 이런 문제를 해결하고 있습니다.
###### Server Push
서버는 클라이언트의 요청에 대해 요청하지도 않은 리소스를 마음대로 보내줄 수도 있습니다.     
클라이언트가 HTML문서를 요청했고 해당 HTML에 여러개의 리소스(CSS, Image…) 가 포함되어 있는 경우                
HTTP/1.1에서 클라이언트는 요청한 HTML문서를 수신한 후 HTML문서를 해석하면서 필요한 리소스를 재요청합니다.        
HTTP/2에선 Server Push를 이용하면 클라이언트가 요청하지도 않은 (HTML문서에 포함된 리소스) 리소스를 Push 해주는 방법으로       
클라이언트의 요청을 최소화 해서 성능 향상을 이끌어 냅니다.       
이를 PUSH_PROMISE 라고 부르며 PUSH_PROMISE를 통해서 서버가 전송한 리소스에 대해선 클라이언트는 요청을 하지 않습니다.
<br><br>
#### 🤔 HTTP 응답코드
클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능을 합니다.
- 1xx (Informational): 요청이 수신되어 처리중
- 2xx (Successful): 요청 정상 처리
- 3xx (Redirection): 요청을 완료하려면 추가 행동이 필요
- 4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음 
- 5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함
###### 자주 사용하는 HTTP 응답 코드
- 200 OK - 요청 성공
- 201 Created - 요청에 따른 새로운 리소스 생성 성공
- 204 No Content - 요청은 성공했지만 딱히 보내줄 내용이 없음
- 400 Bad Request - 잘못된 요청
- 401 Unauthorized - 비인증 요청
- 403 Forbidden - 비승인 요청
- 404 Not Found - 존재하지 않는 리소스에 대한 요청
- 500 Internal Server Error - 서버 에러
- 503 Service Unavailable - 서비스가 이용 불가능함
<br><br>
#### 🤔 HTTP Method - PUT과 PATCH의 차이
- PUT: 리소스의 전체를 클라이언트가 서버에게 보내는 리소스로 업데이트 하는데 사용합니다. (해당 리소스가 없으면 생성합니다.) 
- PATCH: 리소스의 부분적으로 수정하는데 사용합니다. 의미론적으로 UPDATE와 더 가깝다고 할 수 있습니다.
<br><br>
#### 🤔 HTTP Method - GET과 POST의 차이
- GET : 특정 리소스의 참조를 요청합니다. CRUD를 예로 들 경우 R에 해당합니다. url에 어느 리소스를 참조 요청하는지 드러나게 됩니다.
- POST: 서버나 특정 리소스에 엔티티를 제출할 때 사용합니다. Create나 Update, Delete등을 할 때 사용하기도 합니다.
<br><br>
###### HTTP Method의 역할 
HTTP Method를 통해 자원에 대한 처리를 표현합니다.
<br><br>
#### 📚 유익한 자료
[나만 모르고 있던 HTTP/2](https://www.popit.kr/%EB%82%98%EB%A7%8C-%EB%AA%A8%EB%A5%B4%EA%B3%A0-%EC%9E%88%EB%8D%98-http2/)

---
<br><br>
## DNS에 대해서 설명해보세요.
### 핵심 답변

<br><br>
#### 🤔
<br><br>
#### 📚 유익한 자료

---
<br><br>
