# DB
## Relational 데이터베이스와 NoSQL 데이터베이스의 차이에 대해서 설명해주세요.
### 핵심답변
RDBMS는 데이터베이스를 이루는 객체들의 관계 통해서 데이터를 저장하는 데이터베이스입니다.             
SQL을 사용해 데이터의 저장, 질의, 수정, 삭제를 할 수 있으며               
데이터를 효율적으로 보관하는 것을 목적으로 하고 구조화가 굉장히 중요합니다.          
장점으로는 명확한 데이터 구조를 보장하고, 중복을 피할 수 있습니다.          

NOSQL은 RDBMS에 비해 자유로운 형태로 데이터를 저장합니다.           
또한 수평확장을 할 수 있고 분산처리를 지원합니다.            
다양한 형태의 NOSQL 데이터베이스가 있고, 대표적으로 key-value store, document db, graph db 등이 있습니다.         

둘은 대체될 수 있는 것이 아니고, 각각 필요한 시점에 적절히 선택해서 사용해야 합니다. 둘 다 같이쓰는 상호보완적인 존재가 될 수도 있습니다.
<br><br>
#### 🤔 관계형 데이터베이스는 관계를 어떻게 맺을 수 있나요?
관계형 데이터베이스는 테이블이 다른 테이블과 관계를 맺을 때, 외래키를 사용하여 맺을 수 있습니다.
<br><br>
#### 🤔 테이블 간의 관계는 무엇이 있고, 외래키는 무엇인가요?
테이블 간의 관계는 관계를 맺는 테이블의 수에 따라 다음과 같이 나눌 수 있습니다.

<img width="500" src="http://www.tcpschool.com/lectures/img_mysql_relationship.png">

1. 일대일(one-to-one) 관계
2. 일대다(one-to-many) 관계
3. 다대다(many-to-many) 관계

외래 키는 한 테이블의 키 중에서 다른 테이블의 행(row)을 식별할 수 있는 키를 의미합니다.
<br><br>
#### 🤔 NoSQL 데이터베이스가 Relation DB에 비해 Data Update를 하는데 있어 비교적 느린 이유가 무엇인가요?
NoSQL 데이터베이스의 경우 데이터가 여러 컬렉션에 중복되어 있기 때문에, 수정해야 하는 경우 모든 컬렉션을 update 해줘야 합니다.             
하지만, Relational DB에서는 중복 데이터가 없으므로 한번만 수행하면 됩니다.
<br><br>
#### 🤔 데이터베이스의 서버 확장에 대해서 설명해주세요.
데이터베이스 서버의 확장성은 수직적 확장과 수평적 확장으로 나누어집니다.
-   수직적 확장은  단순히 데이터베이스 서버의 성능을 향상시키는 것입니다.(ex. CPU 업그레이드)
-   수평적 확장은 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미합니다.

수평적 확장은 NoSQL DB에서만 가능합니다.          
데이터 저장 방식으로 인해 Relational DB는 일반적으로 수직적 확장만 지원합니다.
<br><br>
#### 🤔 Relational DB가 일반적으로 수직적 확장만 지원하는 이유는 무엇인가요?
관계형 데이터베이스를 수평적 확장하려면 샤딩이 필요합니다.        
ACID 준수를 유지하면서 관계형 데이터베이스를 샤딩하는 것은 매우 까다로운 작업이기 때문입니다.
<br><br>
#### 🤔 어떤 서비스에서 MySQL을 쓸 것 같은지?
관계형 데이터베이스를 쓰기 좋은 경우는 데이터 완전성이 무엇보다 중요한 상황입니다.        
재무 응용프로그램, 방어 및 보안, 개인 건강 정보가 대표적이고 이밖에 고도로 정형화된 데이터, 내부 프로세스의 자동화에도 이 데이터베이스가 적합합니다.
<br><br>
#### 🤔 어떤 서비스에 MongoDB가 적합한지?
상품 사용기나 블로그 댓글 등 비정형 데이터 작업이 많은 경우와 빠른 프로토 타입 작업에 적합합니다.
<br><br>
#### 📚 유익한 자료
- [관계형 데이터베이스](http://www.tcpschool.com/mysql/mysql_intro_relationalDB)
- [SQL vs NoSQL](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Database/SQL%20vs%20NoSQL.md)
- [RDB부터 검색엔진까지··· 내게 꼭 맞는 DB 고르기](https://www.ciokorea.com/news/38041)

---
<br><br>

## 데이터베이스에서 index를 사용하는 이유와 장단점에 대해 설명해주세요.
### 핵심 답변
데이터베이스에서 인덱스를 사용하는 이유는 검색성능을 향상시키기 위함입니다.       
인덱스는 데이터와 데이터의 위치를 포함한 자료구조이며, 찾고자하는 데이터의 위치를 빠르게 찾아주는 역할을 합니다.     

하지만 검색성능을 실질적으로 향상시키기 위해서는          
해당 쿼리가 index를 사용하는지, 카디널리티, Selectivity 같은 요소들이 고려된 인덱스가 생성되어야 합니다.
  
일반적인 경우의 장점으로는 빠른 검색 성능을 들 수 있습니다.      
일반적인 경우의 단점으로는 인덱스를 구성하는 비용 즉, 추가, 수정, 삭제 연산시에 인덱스를 형성하기 위한 추가적인 연산이 수행됩니다.       
따라서, 인덱스를 생성할 때에는 트레이드 오프 관계에 놓여있는 요소들을 종합적으로 고려하여 생성해야합니다.
<br><br>
#### 🤔 추가적인 연산이 필요한 이유는 무엇인가요?
index 트리 자료 구조는 값이 추가 혹은 삭제될 때마다, 트리 균형을 위해 트리 구조의 재분배 및 합병 등 복잡한 연산이 수반됩니다.        
따라서 데이터 갱신보다는 조회에 주로 사용되는 컬럼에 index를 생성하는 것이 유리합니다.
<br><br>
#### 🤔 데이터베이스에서 index를 만들면 성능이 빨라지게 되는 이유를 설명해주세요.
인덱스는 데이터와 데이터의 위치를 포함한 자료구조이기에, 인덱스를 생성하면 데이터를 빠르게 조회할 수 있습니다.      

인덱스를 활용하면, 데이터를 조회하는 `SELECT` 외에도 `UPDATE` 나 `DELETE` 의 성능이 함께 향상됩니다.          
그러한 이유는 해당 연산을 수행하려면 해당 대상을 조회해야만 작업을 할 수 있기 때문입니다.

```sql
--  Joy라는 이름을 업데이트 해주기 위해서는 Joy을 조회해야 한다. 
UPDATE USER SET NAME = 'Hyeyoung' WHERE NAME = 'Joy';
```
<br>

#### 🤔 hash index를 사용했을 때의 단점과 이유를 설명하세요.
단점은 해시 테이블에서는 특정 기준보다 크거나 작은 값을 찾을 때 매우 비효율적입니다.      

해시 테이블은 해시 함수를 통해 나온 해시 값을 이용하여 저장된 메모리 공간에 한 번에 접근을 하기 때문에 O(1)이라는 시간 복잡도를 가집니다.        
(물론 해시 충돌 등으로 최악의 경우에 O(N)이 될 수 있지만, 평균적으로는 O(1)으로 볼 수 있습니다.)

그러나 이는 '단 하나의 데이터를 탐색하는 시간' 에만 O(1)입니다.         
우리는 DB에서 등호(=) 뿐 아니라 부등호(<, >)도 사용할 수 있습니다.

모든 값이 정렬되어있지 않으므로, 해시 테이블에서는 특정 기준보다 크거나 작은 값을 찾을 때 매우 비효율적입니다.         
그렇기에 기준 값보다 크거나 작은 요소들을 항상 탐색할 수 있어야 하는 DB 인덱스 용도로는 해시 테이블은 어울리지 않는 자료구조입니다. 
<br><br>
#### 🤔 인덱스에 왜 해쉬 보다 B Tree를 사용하나요?
B Tree는
이진검색 트리처럼 각 Key의 왼쪽 자식은 항상 Key보다 작은 값을, 오른쪽 자식은 큰 값을 가지고, Balanced Tree입니다.          
B Tree 기반의 DB index는 특정 컬럼의 값(Key)에 해당하는 노드에 데이터의 위치(Value)를 저장합니다.

B Tree는 아래의 이유로 DB 인덱스 용도에 적합합니다.

- 항상 정렬된 상태로 특정 값보다 크고 작은 부등호 연산에 문제가 없습니다.
- 참조 포인터가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능합니다.
- 데이터 탐색뿐 아니라, 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가집니다.

모든 면으로 DB 인덱스 용도로 적합합니다.
<br><br>
#### 🤔 index 대상 컬럼 선장할 때 기준
일반적으로 Cardinality가 높은 컬럼을 우선적으로 인덱싱하는 것이 검색 성능에 유리합니다.      
Cardinality란 특정 데이터 집합의 유니크(Unique)한 값의 개수를 의미합니다다.     

남-여 등 2가지 값만 존재하는 성별 컬럼은 중복도가 높으며 카디널리티가 낮고,        
개인마다 고유한 값이 존재하는 주민번호 컬럼은 중복도가 낮으며 카디널리티가 높습니다.            
Cardinality 높은 컬럼의 경우, Index를 통해 데이터를 더 많이 필터링할 수 있기 때문에 해당 컬럼을 우선적으로 인덱싱하는 것이 검색 성능에 유리합니다.
<br><br>
#### 📚 유익한 자료
- [How Does Indexing Work](https://chartio.com/learn/databases/how-does-indexing-work/)
- [위키백과 - 인덱스 (데이터베이스)](https://ko.wikipedia.org/wiki/%EC%9D%B8%EB%8D%B1%EC%8A%A4_(%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4))
- [위키백과 - B+ 트리](https://ko.wikipedia.org/wiki/B%2B_%ED%8A%B8%EB%A6%AC)
- [B - Tree Data structure](http://www.btechsmartclass.com/data_structures/b-trees.html)
- [DB 인덱스(INDEX) 자료구조](https://junhyunny.github.io/information/data-structure/db-index-data-structure/)
- [인덱스(index)란?](https://mangkyu.tistory.com/96)
- [[자료구조] 그림으로 알아보는 B-Tree](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree)
- [Binary Search Tree에서 B+Tree까지(Database Index 추가)](https://velog.io/@jewelrykim/Binary-Search-Tree%EC%97%90%EC%84%9C-BTree%EA%B9%8C%EC%A7%80Database-Index-%EC%B6%94%EA%B0%80)

---
<br><br>

## 트랜잭션이 무엇인가요.
### 핵심 답변
트랜잭션은 하나의 논리적 작업 단위를 구성하는 일련의 연산들의 집합을 말합니다.                
트랜잭션의 예로 게좌 간의 자금 이체가 많이 언급됩니다.             
한 계좌에서 10만원을 인출하면 다른 계좌로 10만원 입금하는 이체 작업은 전체 작업이 정상적으로 완료되거나,           
만약 정상적으로 처리될 수 없는 경우에는 아무 것도 실행 되지 않는 처음 상태로 되돌려져야 합니다.         
이러한 트랜잭션은 다양한 데이터 항목들을 접근하고 갱신하는 프로그램의 수행의 단위가 됩니다.
<br><br>
#### 🤔 트랜잭션의 특성에 대해 설명해주세요(ACID)
ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질입니다.

- Atomicity(원자성) : 트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 아니면, 전혀 어떠한 연산도 수행되지 않은 상태를 보장해야 합니다. 
- Consistency(일관성) : 트랜잭션이 진행되는 동안에 데이터베이스가 변경되더라도 업데이트된 데이터베이스로 트랜잭션이 진행되는 것이 아닌 트랜잭션이 진행하기 전 참조한 데이터베이스로 진행되어야 합니다.
- Isolation(독립성) : 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행되어야 합니다.
- Durability(지속성) : 트랜잭션이 성공적으로 완료되어 커밋되고 나면, 해당 트랜잭션에 의한 모든 변경은 향후에 어떤 소프트웨어나 하드웨어 장애가 발생되더라도 보존되어야 합니다.
<br><br>
###### 트랜잭션이 독립적으로 실행된다는 말은 무엇인가요?
하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없고            
수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다는 것을 말합니다.
<br><br>
###### 트랜잭션 수행이 보존해야 할 일관성은 무엇이 있을까요?
기본 키, 외래 키 제약과 같은 명시적인 무결성 제약 조건들뿐만 아니라,        
자금 이체 예에서 두 계좌 잔고의 합은 이체 전후가 같아야 한다는 사항과 같은 비명시적인 일관성 조건들도 있습니다.
<br><br>
#### 🤔 트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해주세요.
트랜잭션 격리수준은 고립도와 성능의 트레이드 오프를 조절합니다.

- READ UNCOMMITTED: 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있습니다.
  -  따라서 오염된 읽기, 재현 불가한 읽기, 허상 읽기 문제가 발생할 가능성이 있습니다.
- READ COMMITTED: 다른 트랜잭션에서 커밋된 내용만 참조할 수 있습니다.
  - 이로써 오염된 값 읽기 문제는 해결되지만 재현 불가한 읽기, 허상 읽기 문제는 여전히 남습니다.
- REPEATABLE READ: 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있습니다.
  -  오염된 값 읽기, 재현 불가한 읽기 문제는 해결되지만 허상 읽기는 여전히 남습니다.
- SERIALIZABLE: 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 합니다. 동시성 문제는 모두 해소되지만 성능이 매우 떨어집니다. 

Durty Read, Nonrepeatable Read와 같은 문제를 예방하려면 트랜잭션을 서로 완전히 격리 하면 되겠지만            
그렇게 하면 트랜잭션을 한 줄로 세워놓고 하나씩 실행하는 꼴이라서 엄청난 성능 저하가 옵니다.                
그래서, 성능을 감안하며, 요건을 충족하는 가장 낮은 수준의 트랜잭션 격리 수준을 선택하는게 좋습니다.
<br><br>
###### 오염된 읽기, 재현 불가능한 읽기, 허상 읽기, 소실된 수정
이름 | 설명
---|---
오염된 읽기 Duty Read | T2가 수정후 커밋하지 않은 필드를 T1이 읽는상황에서 **나중에 T2가 롤백되면 T1이 읽은 필드를 일시적인 값으로 더이상 유효하지 않습니다.**
재현 불가한 읽기 Nonrepeatable Read | 어떤 필드를 T1이 읽은 후 T2가 수정할 경우, **T1이 같은 필드를 다시 읽으면 다른 값을 얻습니다.**
허상 읽기 Phantom Read | T1이 테이블의 로우를 몇개를 읽은 후 T2가 같은 테이블에 새 로우를 삽입할 경우, 나중에 T1이 같은 테이블을 다시 읽으면 T2가 삽입한 로우가 보입니다.
소실된 수정 Lost Update | T1, T2가 모두 어떤 로우를 수정하려고 읽고 그 로우의 상태에 따라 수정하는 경우입니다. T1이 먼저 로우를 수정 후 커밋하기 전, T2가 T1이 수정한 로우를 똑같이 수정했다면 T1이 커밋한 후에 T2 역시 커밋하게 됩니다. 그러면 **T1이 수정한 로우를 T2가 넢어쓰게 되어 T1이 수정한 내용이 소실됩니다.**
<br>

#### 🤔 트랜잭션 잠금에 대해서 설명해주세요.
<br><br>
#### 🤔 잠금 타임아웃과 교착 상태가 발생하는 이유에 대해서 설명해주세요.
<br><br>
#### 🤔 트랜잭션 Rollback은 어떤 경우에 하나요?
하나의 트랜잭션 처리가 비정상적으로 종료되면 트랜잭션의 원자성을 위해 롤백을 사용합니다.     
트랜잭션을 사용해 데이터를 추가하다 에러가 발생할 때,    
트랜잭션을 롤백함으로써 해당 트랜잭션에서 작업한 모든 연산을 취소하여 실제 데이터베이스에 반영하지 않도록 합니다.       
롤백하고 난 후에는 해당 트랜잭션을 재시작하거나 폐기해야 합니다.
<br><br>
#### 📚 유익한 자료

---
<br><br>

## Elastic Search에 대해서 간단히 설명해주세요.
### 핵심 답변
Elastic Search는 자바로 개발된 오픈소스 검색엔진 입니다.          
보통 단독으로 사용하기보다는 ELK 스택이라고 부르는 Logstash, Kibana, Beats를 추가적으로 사용합니다.             
Inverted Index 구조로 데이터를 저장해서, 전문(Full-text) 검색시에 RDBMS에 비해 뛰어난 성능을 보장합니다.               
다양한 용도로 사용할 수 있습니다. (데이터 저장, 문서 검색, 위치 검색, 머신 러닝 기반 검색, 로그 분석, 보안 감사 분석 등)
<br><br>
#### 🤔 Elastic Search의 인덱스구조와 RDBMS의 인덱스 구조의 차이에 대해 설명해주세요.
Elastic Search는 Inverted-Index 구조로 데이터를 저장합니다.        
이는 책의 색인을 생각해보면 쉬운데, 특정 단어가 출현하는 doc을 저장하는 것입니다.          
반면 RDBMS는 B-Tree와 그와 유사한 인덱스를 사용합니다. 데이터가 어디에 존재하는지 어떤 순서로 저장하는 지의 차이라고 생각합니다.       
RDBMS에도 다양한 인덱스 구조가 있으나 여기서 예로 든 것은 B-Tree 인덱스입니다.
<br><br>
#### 🤔 Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.
Elastic Search의 키워드 검색은 document를 저장할 때 수행하는 알고리즘과 동일한 알고리즘으로 키워드를 분리합니다.           
그 중에서 랭킹알고리즘을 통해서 가장 유사한 순서대로 결과를 나타냅니다.          
RDBMS에서의 LIKE 검색은 와일드카드로 시작하지 않는 경우에만 인덱스를 사용하고 나머지 경우는 전체를 탐색하기 때문에 상대적으로 느립니다.
<br><br>
###### 역인덱싱에 대해 자세히 설명해주세요.
역인덱싱은 대용량 텍스트의 효율적인 검색을 위해 고안된 방법으로         
문서를 유의미한 단어로 분리하여 정렬된 목록을 작성한 후에, 각 단어가 어느 문서에 있는지 표시하여 작성하는 작업입니다.         
이 방법은 단어들이 이미 정렬되어 있기 때문에 검색 및 탐색의 속도가 매우 빠릅니다.     

이 때 문서를 유의미한 단어로 분리하기 위해 형태소 분석 과정을 거칩니다.
<br><br>
#### 📚 유익한 자료
- [Inverted Index](https://esbook.kimjmin.net/06-text-analysis/6.1-indexing-data)
---
<br><br>

## 정규화에 대해서 설명해주세요.
정규화는 데이터의 중복 방지와 데이터에서 일어날 수 있는 이상 현상을 방지를 위해 데이터베이스를 설계하는 것을 의미합니다.        
정규화를 거치면, 크고 제대로 조직되지 않는 테이블들을 작게 나누면서 데이터의 중복을 없애고 잘 조직된 구조로 만들어지게 됩니다.
<br><br>
#### 🤔 제 1, 2, 3 정규화에 대해서 설명하세요.
###### 제 1정규화      
제 1정규화는 테이블의 각 속성이 복합적인 값을 포함하지 말아야 합니다.              
요즘 쓰이는 RDBMS에서는 테이블을 만들 때 각 칼럼이 원자적인 속성일 것을 강제하기 때문에 지켜지지 않는 경우가 거의 없습니다.       
또한, 중복되는 항목이 없어야 하고, 기본 키로 각 행을 식별할 수 있어야 합니다.

###### 제 2정규화      
제 2정규화는 제 1정규화를 만족하면서, 하나의 속성으로만 후보 키로 사용하는 것입니다.          
후보키란 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합입니다.

<img width="400" alt="스크린샷 2022-02-14 21 43 36" src="https://user-images.githubusercontent.com/29566893/153866915-ecf6496f-0675-408d-b5ed-416f3b056517.png">

위 테이블은 종업원과 기술 두 속성을 모두 사용해야 후보 키로 쓸 수 있습니다.        
즉, 후보키는 {종업원, 기술}입니다.       
그러나, 근무지 속성은 종업원 속성에만 종속되어 있으며, 근무지 속성은 중복됩니다.      
이 테이블에서는 Jones의 근무지를 갱신할 때, Typing, Shorthand에 대한 근무지만 갱신될 수 있는 위험이 있습니다.

<img width="400" alt="스크린샷 2022-02-14 21 43 45" src="https://user-images.githubusercontent.com/29566893/153866920-b76a24da-89de-497c-be9a-e5363a6be023.png">

제 2정규화를 만족시키기 위해, 기존 테이블을 분해한 예시 입니다.       
이 구조에서는 갱신 이상이 발생하지 않습니다.       
그러나, 제 2정규화를 만족시키는 모든 테이블이 갱신 이상이 없는 것은 아닙니다.

###### 제 3정규화
제 3정규화는 제 2정규화를 만족하면서, 모든 속성이 기본 키에 대해서만 의존되어야 합니다.
이 조건은 자연히 추이 종속성이 발생하지 않을 것을 요구합니다.

<img width="400" alt="스크린샷 2022-02-14 21 44 27" src="https://user-images.githubusercontent.com/29566893/153866928-ca52aef4-3d7b-491f-a1fc-e051008a5e03.png">
<img width="400" alt="스크린샷 2022-02-14 21 44 41" src="https://user-images.githubusercontent.com/29566893/153866930-e906ff1b-e90f-482b-a29e-7686f5a0fd31.png">

위의 테이블의 경우 기본 키에 의해서만 모든 속성이 결정됩니다.         
대회 우승자 테이블은 {대회, 연도}가 기본 키이고, 우승자 생년 월일 테이블은 {우승자}가 기본키입니다.     
제 3정규화 에서는 갱신 이상이 덜 발생합니다.
<br><br>
#### 🤔 잘 조직되지 않는 테이블에서 일어날 수 있는 이상들은 무엇인가요?
대표적 이상은 삽입 이상과 삭제 이상과 갱신 이상입니다.         
삽입 이상은 관계에 데이터를 삽입할 때 의도와 상관없이 원하지 않는 값들도 함께 삽입되는 현상입니다.        
삭제 이상은 관계에 데이터를 삭제할 때 의도와 상관없는 값들도 함께 삭제되는 현상입니다.       
갱신 이상은 관계의 행에 있는 속성 값을 갱신할 때 일부 행의 데이터만 갱신되어 데이터에 모순이 생기는 현상입니다.        
정규화를 거치면, 위의 이상들이 일어나지 않도록 할 수 있습니다.        
또한, 현실적으로 과도한 정규화는 DB 질의 처리 속도를 떨어 뜨리기 때문에 제 3 정규화 또는 보이스 코드 정규화까지만 정규화를 진행하며, 필요에 따라 비정규화 작업을 하기도 합니다.
<br><br>
#### 🤔 Denormalization은 무엇이고, 언제 시행하게 되는지 설명해주세요.
비정규화는 정규화의 반대 개념으로, 중복 데이터를 허용하는 것입니다. 비정규화는 성능을 상당히 개선시킬 수 있기 때문에 사용합니다.     
데이터가 비정규화되면 테이블을 여러 개씩 읽을 필요도 없고 여러 컬렉션에 있는 데이터에 조인을 수행할 필요도 없습니다.      
대신 단일 컬렉션이나 문서에서 데이터를 읽으면 됩니다.    
이렇게 하면, 특히 인덱스를 사용할 수 있을 때 컬렉션 여러 개에서 데이터를 추출하는 것보다 훨씬 속도가 빠릅니다.
<br><br>
#### 📚 유익한 자료
- [개념 정리 - (9) 데이터베이스 편](https://brunch.co.kr/@toughrogrammer/17)
- [비정규화](https://thebook.io/006765/part03/ch07/03/02/)

---
<br><br>
## JPA란?
### 핵심답변
JPA란 Java Persistance API의 약자로 JAVA ORM 표준 기술입니다.       
자바에서 데이터를 DBMS에 영구히 기록할 수 있는 환경을 제공하는 API입니다.
<br><br>
#### 🤔 ORM이란 무엇인가요
객체와 관계형 데이터베이스를 매핑해주는 것으로 쿼리문 작성 없이 객체를 데이터베이스에 직접 저장할 수 있게 도와주는 기술입니다.
<br><br>
#### 🤔 JPA를 사용할 때의 이점에 대해서 설명해주세요.
JPA가 있다면, 자바 언어로 구현하다가, 갑자기 SQL로 구현해주지 않아도 됩니다.       
JPA를 통해 SQL을 자바로 만들 수 있고, 그 결과 유지보수가 쉽습니다.

JPA를 사용하지 않았을 때는 필드 변경 시, 모든 SQL을 수정해야 했습니다.      
하지만, JPA를 사용했을 때는 필드가 변경 시, 필드만 변경해주면 됩니다. SQL은 JPA가 처리하기 때문에 손댈 것이 없습니다.
<br><br>
#### 🤔 JPA, Hibernate 그리고 Spring Data JPA 각각에 대해서 설명해주세요.
<img width="500" src="https://suhwan.dev/images/jpa_hibernate_repository/overall_design.png">

######JPA
JPA는 기술 명세입니다.            
자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스입니다.
예를 들어, JPA의 핵심이 되는 EntityManager는 아래와 같이 javax.persistence.EntityManager 라는 파일에 interface로 정의되어 있습니다.
```java
package javax.persistence;

import ...

public interface EntityManager {

    public void persist(Object entity);

    public <T> T merge(T entity);

    public void remove(Object entity);

    public <T> T find(Class<T> entityClass, Object primaryKey);

    // More interface methods...
}
```

###### Hibernate
Hibernate는 JPA의 구현체입니다.     
javax.persistence.EntityManager와 같은 인터페이스를 직접 구현한 라이브러리입니다.

###### Spring Data JPA
Spring Data JPA는 Spring에서 제공하는 모듈 중 하나로, 개발자가 JPA를 더 쉽고 편하게 사용할 수 있도록 도와줍니다.            
이는 JPA를 한 단계 추상화시킨 Repository라는 인터페이스를 제공함으로써 이루어집니다.           
사용자가 Repository 인터페이스에 정해진 규칙대로 메소드를 입력하면, Spring이 알아서 해당 메소드 이름에 적합한 쿼리를 날리는 구현체를 만들어서 Bean으로 등록해줍니다.
<br><br>
#### 🤔 데이터 정합성에 대해서 설명해주세요. JPA에서 이것들을 어떻게 처리하는가요?
<br><br>
#### 🤔 DB Lock에 대해서 설명해주세요. JPA에서 이것들을 어떻게 처리하는가요?
<br><br>
#### 📚 유익한 자료
- [JPA, Hibernate, 그리고 Spring Data JPA의 차이점](https://suhwan.dev/2019/02/24/jpa-vs-hibernate-vs-spring-data-jpa/)

---
